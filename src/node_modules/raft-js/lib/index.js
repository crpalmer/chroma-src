"use strict";
/**
 * @module Raft
 * @preferred
 */ /** */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = require("./parsers/base");
const invalid_argument_1 = require("./errors/invalid-argument");
const bad_method_call_1 = require("./errors/bad-method-call");
class RaftWrapper {
    constructor(parser) {
        if (!(parser instanceof base_1.default)) {
            throw new invalid_argument_1.default("Invalid RaftParser instance provided");
        }
        this.instructions = [];
        this.programCounter = 0;
        this.parser = parser;
    }
    clone() {
        let copy = new RaftWrapper(this.parser.clone());
        copy.instructions = this.instructions.slice();
        copy.programCounter = this.programCounter;
        return copy;
    }
    getCurrentInstruction() {
        if (this.instructions.length === 0) {
            throw new bad_method_call_1.default("No instructions have been loaded.");
        }
        if (this.programCounter === 0) {
            throw new bad_method_call_1.default("No instructions have yet been executed.");
        }
        if (this.programCounter > this.instructions.length) {
            throw new bad_method_call_1.default("Program counter is already at end of instruction list.");
        }
        return this.instructions[this.programCounter - 1];
    }
    getParser() {
        return this.parser;
    }
    getEngine() {
        return this.parser.getEngine();
    }
    getCurrentState() {
        return this.getEngine().getCurrentState();
    }
    open(inpath) {
        let contents = this.parser.readFile(inpath);
        this.instructions = this.parser.parse(contents);
    }
    save(outpath) {
        let contents = this.parser.toOutput(this.instructions);
        this.parser.writeFile(outpath, contents);
    }
    stepForward() {
        if (this.programCounter === this.instructions.length) {
            return false;
        }
        this.programCounter++;
        if (this.getEngine().needsExecuteForNextInstruction()) {
            this.getEngine().executeNext(this.getCurrentInstruction());
        }
        else {
            this.getEngine().stepForward();
        }
        return true;
    }
    stepBackward() {
        if (this.programCounter === 0) {
            return false;
        }
        this.programCounter--;
        this.getEngine().stepBackward();
        return true;
    }
    play(iteratorCallback) {
        return __awaiter(this, void 0, void 0, function* () {
            let _this = this;
            return new Promise(function (resolve, reject) {
                return __awaiter(this, void 0, void 0, function* () {
                    if (iteratorCallback !== undefined && (typeof iteratorCallback !== "function")) {
                        reject();
                        throw new invalid_argument_1.default("Invalid callback function provided");
                    }
                    let useCB = (iteratorCallback !== undefined);
                    while (_this.programCounter < _this.instructions.length) {
                        _this.stepForward();
                        if (useCB) {
                            try {
                                yield iteratorCallback(_this.getCurrentInstruction(), _this.getCurrentState(), _this.programCounter);
                            }
                            catch (e) {
                                reject(e);
                                return;
                            }
                        }
                    }
                    resolve();
                });
            });
        });
    }
    rewind() {
        while (this.programCounter > 0) {
            this.stepBackward();
        }
    }
    insertInstruction(instruction) {
        this.getEngine().invalidateFuture();
        this.instructions.splice(this.programCounter, 0, instruction);
        this.stepForward();
    }
    deleteInstruction() {
        if (this.programCounter >= this.instructions.length) {
            throw new bad_method_call_1.default("Cannot delete; all instructions have been executed.");
        }
        this.getEngine().invalidateFuture();
        this.instructions.splice(this.programCounter, 1);
    }
}
exports.RaftWrapper = RaftWrapper;
__export(require("./enums"));
__export(require("./engines"));
__export(require("./errors"));
__export(require("./instructions"));
__export(require("./parsers"));
__export(require("./state-machines"));
//# sourceMappingURL=index.js.map