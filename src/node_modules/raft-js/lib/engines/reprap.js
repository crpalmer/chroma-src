"use strict";
/**
 * @module RaftEngine
 */ /** */
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = require("./base");
const invalid_instruction_1 = require("../errors/invalid-instruction");
const enums_1 = require("../enums");
const linear_move_1 = require("../instructions/linear-move");
const arc_move_1 = require("../instructions/arc-move");
const dwell_1 = require("../instructions/dwell");
const empty_1 = require("../instructions/empty");
const get_position_1 = require("../instructions/get-position");
const set_coordinate_mode_1 = require("../instructions/set-coordinate-mode");
const set_position_1 = require("../instructions/set-position");
const home_1 = require("../instructions/home");
const toolchange_1 = require("../instructions/toolchange");
const set_toolhead_temperature_1 = require("../instructions/set-toolhead-temperature");
const set_fan_1 = require("../instructions/set-fan");
const set_bed_temperature_1 = require("../instructions/set-bed-temperature");
const stop_idle_hold_1 = require("../instructions/stop-idle-hold");
const disable_stepper_motor_1 = require("../instructions/disable-stepper-motor");
const set_units_1 = require("../instructions/set-units");
const sleep_1 = require("../instructions/sleep");
const stop_1 = require("../instructions/stop");
const emergency_stop_1 = require("../instructions/emergency-stop");
const finish_buffer_1 = require("../instructions/finish-buffer");
const display_message_1 = require("../instructions/display-message");
const retract_1 = require("../instructions/retract");
const set_tool_offset_1 = require("../instructions/set-tool-offset");
const bed_standby_1 = require("../instructions/bed-standby");
const stabilize_toolhead_temperature_1 = require("../instructions/stabilize-toolhead-temperature");
const stabilize_temperature_1 = require("../instructions/stabilize-temperature");
const stabilize_all_temperatures_1 = require("../instructions/stabilize-all-temperatures");
const set_pid_sample_interval_1 = require("../instructions/set-pid-sample-interval");
const set_max_print_acceleration_1 = require("../instructions/set-max-print-acceleration");
const set_max_jerk_speed_1 = require("../instructions/set-max-jerk-speed");
const offset_axis_1 = require("../instructions/offset-axis");
const set_retract_length_1 = require("../instructions/set-retract-length");
const set_speed_override_1 = require("../instructions/set-speed-override");
const set_extrusion_override_1 = require("../instructions/set-extrusion-override");
const pause_1 = require("../instructions/pause");
const play_beep_1 = require("../instructions/play-beep");
const set_axis_travel_bound_1 = require("../instructions/set-axis-travel-bound");
const limit_axis_travel_1 = require("../instructions/limit-axis-travel");
const extrusion_axis_1 = require("../state-machines/extrusion-axis");
const print_1 = require("../state-machines/print");
const non_negative_axis_1 = require("../state-machines/non-negative-axis");
const integer_1 = require("../state-machines/integer");
const start_sd_print_1 = require("../instructions/start-sd-print");
const pause_sd_print_1 = require("../instructions/pause-sd-print");
const util_1 = require("util");
const offset_axis_2 = require("../state-machines/offset-axis");
const standby_axis_1 = require("../state-machines/standby-axis");
const unknown_1 = require("../instructions/unknown");
const o_start_multicolor_1 = require("../instructions/o-start-multicolor");
const o_soft_reset_1 = require("../instructions/o-soft-reset");
const o_splice_data_1 = require("../instructions/o-splice-data");
const hex_1 = require("../common/hex");
const o_splice_count_1 = require("../instructions/o-splice-count");
const o_ping_data_1 = require("../instructions/o-ping-data");
const set_max_feedrate_1 = require("../instructions/set-max-feedrate");
const o_algorithm_count_1 = require("../instructions/o-algorithm-count");
const z_probe_1 = require("../instructions/z-probe");
const o_version_1 = require("../instructions/o-version");
const o_printer_profile_1 = require("../instructions/o-printer-profile");
const o_slicer_profile_1 = require("../instructions/o-slicer-profile");
const o_adjusted_ppm_1 = require("../instructions/o-adjusted-ppm");
const o_materials_used_1 = require("../instructions/o-materials-used");
const o_ping_count_1 = require("../instructions/o-ping-count");
const o_hot_swap_count_1 = require("../instructions/o-hot-swap-count");
const o_algorithm_data_1 = require("../instructions/o-algorithm-data");
const o_hot_swap_data_1 = require("../instructions/o-hot-swap-data");
class RepRapEngine extends base_1.default {
    constructor(options) {
        super(options);
        this.toolheadCount = options.toolheadCount;
        this.independentExtruders = options.independentExtruders || false;
        this.volumetricExtrusion = options.volumetricExtrusion;
        this.defaultHomeDirectionMax = options.defaultHomeDirectionMax || false;
        this.filamentDiameter = options.filamentDiameter;
        if (this.independentExtruders) {
            for (let i = 0; i < this.toolheadCount; i++) {
                this.stateMachines["xTool" + i] = new offset_axis_2.default(new offset_axis_2.OffsetAxisState({
                    coordinateMode: options.initialXYZCoordinateMode,
                    position: null,
                    offset: 0
                }));
                this.stateMachines["yTool" + i] = new offset_axis_2.default(new offset_axis_2.OffsetAxisState({
                    coordinateMode: options.initialXYZCoordinateMode,
                    position: null,
                    offset: 0
                }));
                this.stateMachines["zTool" + i] = new offset_axis_2.default(new offset_axis_2.OffsetAxisState({
                    coordinateMode: options.initialXYZCoordinateMode,
                    position: null,
                    offset: 0
                }));
            }
        }
        else {
            this.stateMachines["x"] = new offset_axis_2.default(new offset_axis_2.OffsetAxisState({
                coordinateMode: options.initialXYZCoordinateMode,
                position: null,
                offset: 0
            }));
            this.stateMachines["y"] = new offset_axis_2.default(new offset_axis_2.OffsetAxisState({
                coordinateMode: options.initialXYZCoordinateMode,
                position: null,
                offset: 0
            }));
            this.stateMachines["z"] = new offset_axis_2.default(new offset_axis_2.OffsetAxisState({
                coordinateMode: options.initialXYZCoordinateMode,
                position: null,
                offset: 0
            }));
        }
        this.stateMachines["extrusion"] = new extrusion_axis_1.default(new extrusion_axis_1.ExtrusionAxisState({
            coordinateMode: options.initialExtrusionCoordinateMode,
            position: null,
            totalDispensed: 0,
            retraction: 0,
            retractDistance: null,
            unretractExtraLength: null
        }));
        this.stateMachines["feedrate"] = new non_negative_axis_1.default(new non_negative_axis_1.NonNegativeAxisState({
            position: null
        }));
        this.stateMachines["extruderTemp"] = new standby_axis_1.default(new standby_axis_1.StandbyAxisState({
            position: null,
            standby: true
        }));
        this.stateMachines["bedTemp"] = new standby_axis_1.default(new standby_axis_1.StandbyAxisState({
            position: null,
            standby: true
        }));
        this.stateMachines["fan"] = new non_negative_axis_1.default(new non_negative_axis_1.NonNegativeAxisState({
            position: util_1.isNullOrUndefined(options.initialFanSpeed) ? null : options.initialFanSpeed
        }));
        this.stateMachines["toolhead"] = new integer_1.default(new integer_1.IntegerState({
            value: util_1.isNullOrUndefined(options.initialToolheadIndex) ? null : options.initialToolheadIndex
        }));
        this.stateMachines["printState"] = new print_1.default(new print_1.PrintState({
            value: util_1.isNullOrUndefined(options.initialPrintState) ? enums_1.PrintStates.None : options.initialPrintState
        }));
    }
    clone() {
        let copy = new RepRapEngine({
            toolheadCount: this.toolheadCount,
            independentExtruders: this.independentExtruders,
            volumetricExtrusion: this.volumetricExtrusion,
            defaultHomeDirectionMax: this.defaultHomeDirectionMax,
            filamentDiameter: this.filamentDiameter,
            initialXYZCoordinateMode: this.stateMachines["x"].getCurrentState().coordinateMode,
            initialExtrusionCoordinateMode: this.stateMachines["extrusion"].getCurrentState().coordinateMode
        });
        this.copyStateMachinesTo(copy);
        return copy;
    }
    toRaftInstruction(line) {
        if (!line.command) {
            return new empty_1.default({
                comment: line.comment
            });
        }
        if (line.command === "G0" || line.command === "G1")
            return fromG0G1(line);
        if (line.command === "G2" || line.command === "G3")
            return fromG2G3(line);
        if (line.command === "G4")
            return fromG4(line);
        if (line.command === "G10" || line.command === "G11")
            return fromG10G11(line);
        if (line.command === "G20" || line.command === "G21")
            return fromG20G21(line);
        if (line.command === "G28")
            return fromG28(line);
        if (line.command === "G29")
            return fromG29(line);
        if (line.command === "G90")
            return fromG90(line);
        if (line.command === "G91")
            return fromG91(line);
        if (line.command === "G92")
            return fromG92(line);
        if (line.command === "M0")
            return fromM0(line);
        if (line.command === "M1")
            return fromM1(line);
        if (line.command === "M18")
            return fromM18(line);
        if (line.command === "M24")
            return fromM24(line);
        if (line.command === "M25")
            return fromM25(line);
        if (line.command === "M82")
            return fromM82(line);
        if (line.command === "M83")
            return fromM83(line);
        if (line.command === "M84")
            return fromM84(line);
        if (line.command === "M104")
            return fromM104(line);
        if (line.command === "M106")
            return fromM106(line);
        if (line.command === "M107")
            return fromM107(line);
        if (line.command === "M109")
            return fromM109(line);
        if (line.command === "M112")
            return fromM112(line);
        if (line.command === "M114")
            return fromM114(line);
        if (line.command === "M116")
            return fromM116(line);
        if (line.command === "M117")
            return fromM117(line);
        if (line.command === "M135")
            return fromM135(line);
        if (line.command === "M140")
            return fromM140(line);
        if (line.command === "M144")
            return fromM144(line);
        if (line.command === "M190")
            return fromM190(line);
        if (line.command === "M201")
            return fromM201(line);
        if (line.command === "M203")
            return fromM203(line);
        if (line.command === "M206")
            return fromM206(line);
        if (line.command === "M207")
            return fromM207(line);
        if (line.command === "M208")
            return fromM208(line);
        if (line.command === "M220")
            return fromM220(line);
        if (line.command === "M221")
            return fromM221(line);
        if (line.command === "M226")
            return fromM226(line);
        if (line.command === "M300")
            return fromM300(line);
        if (line.command === "M400")
            return fromM400(line);
        if (line.command === "M564")
            return fromM564(line);
        if (line.command === "M566")
            return fromM566(line);
        if (line.command[0].toUpperCase() === "T")
            return fromT(line);
        return super.toRaftInstruction(line);
    }
    toOutputInstruction(instruction) {
        if (instruction instanceof empty_1.default) {
            return {
                command: null,
                comment: instruction.comment
            };
        }
        if (instruction instanceof unknown_1.default) {
            return {
                command: null,
                original: instruction.original,
                comment: instruction.comment
            };
        }
        if (instruction instanceof linear_move_1.default)
            return fromLinearMove(instruction);
        if (instruction instanceof arc_move_1.default)
            return fromArcMove(instruction);
        if (instruction instanceof dwell_1.default)
            return fromDwell(instruction);
        if (instruction instanceof set_tool_offset_1.default)
            return fromSetToolOffset(instruction);
        if (instruction instanceof retract_1.default)
            return fromRetract(instruction);
        if (instruction instanceof set_units_1.default)
            return fromSetUnits(instruction);
        if (instruction instanceof home_1.default)
            return fromHome(instruction);
        if (instruction instanceof z_probe_1.default)
            return fromZProbe(instruction);
        if (instruction instanceof set_coordinate_mode_1.default)
            return fromSetCoordinateMode(instruction);
        if (instruction instanceof set_position_1.default)
            return fromSetPosition(instruction);
        if (instruction instanceof stop_1.default)
            return fromStop(instruction);
        if (instruction instanceof sleep_1.default)
            return fromSleep(instruction);
        if (instruction instanceof disable_stepper_motor_1.default)
            return fromDisableStepperMotor(instruction);
        if (instruction instanceof start_sd_print_1.default)
            return fromStartSDPrint(instruction);
        if (instruction instanceof pause_sd_print_1.default)
            return fromPauseSDPrint(instruction);
        if (instruction instanceof stop_idle_hold_1.default)
            return fromStopIdleHold(instruction);
        if (instruction instanceof set_toolhead_temperature_1.default)
            return fromSetToolheadTemperature(instruction);
        if (instruction instanceof set_fan_1.default)
            return fromSetFan(instruction);
        if (instruction instanceof emergency_stop_1.default)
            return fromEmergencyStop(instruction);
        if (instruction instanceof get_position_1.default)
            return fromGetPosition(instruction);
        if (instruction instanceof stabilize_temperature_1.default)
            return fromStabilizeTemperature(instruction);
        if (instruction instanceof display_message_1.default)
            return fromDisplayMessage(instruction);
        if (instruction instanceof set_pid_sample_interval_1.default)
            return fromSetPIDSampleInterval(instruction);
        if (instruction instanceof bed_standby_1.default)
            return fromBedStandby(instruction);
        if (instruction instanceof set_bed_temperature_1.default)
            return fromSetBedTemperature(instruction);
        if (instruction instanceof set_max_print_acceleration_1.default)
            return fromSetMaxPrintAcceleration(instruction);
        if (instruction instanceof set_max_feedrate_1.default)
            return fromSetMaxFeedrate(instruction);
        if (instruction instanceof offset_axis_1.default)
            return fromOffsetAxis(instruction);
        if (instruction instanceof set_retract_length_1.default)
            return fromSetRetractLength(instruction);
        if (instruction instanceof set_axis_travel_bound_1.default)
            return fromSetAxisTravelBound(instruction);
        if (instruction instanceof set_speed_override_1.default)
            return fromSetSpeedOverride(instruction);
        if (instruction instanceof set_extrusion_override_1.default)
            return fromSetExtrusionOverride(instruction);
        if (instruction instanceof pause_1.default)
            return fromPause(instruction);
        if (instruction instanceof play_beep_1.default)
            return fromPlayBeep(instruction);
        if (instruction instanceof finish_buffer_1.default)
            return fromFinishBuffer(instruction);
        if (instruction instanceof limit_axis_travel_1.default)
            return fromLimitAxisTravel(instruction);
        if (instruction instanceof set_max_jerk_speed_1.default)
            return fromSetMaxJerkSpeed(instruction);
        if (instruction instanceof toolchange_1.default)
            return fromToolChange(instruction);
        if (instruction instanceof o_start_multicolor_1.default)
            return fromOStartMulticolor(instruction);
        if (instruction instanceof o_soft_reset_1.default)
            return fromOSoftReset(instruction);
        if (instruction instanceof o_version_1.default)
            return fromOVersion(instruction);
        if (instruction instanceof o_printer_profile_1.default)
            return fromOPrinterProfile(instruction);
        if (instruction instanceof o_slicer_profile_1.default)
            return fromOSlicerProfile(instruction);
        if (instruction instanceof o_adjusted_ppm_1.default)
            return fromOAdjustedPPM(instruction);
        if (instruction instanceof o_materials_used_1.default)
            return fromOMaterialsUsed(instruction);
        if (instruction instanceof o_splice_count_1.default)
            return fromOSpliceCount(instruction);
        if (instruction instanceof o_ping_count_1.default)
            return fromOPingCount(instruction);
        if (instruction instanceof o_algorithm_count_1.default)
            return fromOAlgorithmCount(instruction);
        if (instruction instanceof o_hot_swap_count_1.default)
            return fromOHotSwapCount(instruction);
        if (instruction instanceof o_splice_data_1.default)
            return fromOSpliceData(instruction);
        if (instruction instanceof o_ping_data_1.default)
            return fromOPingData(instruction);
        if (instruction instanceof o_algorithm_data_1.default)
            return fromOAlgorithmData(instruction);
        if (instruction instanceof o_hot_swap_data_1.default)
            return fromOHotSwapData(instruction);
        return super.toOutputInstruction(instruction);
    }
    executeNext(instruction) {
        if (instruction instanceof linear_move_1.default || instruction instanceof arc_move_1.default) {
            let xKey, yKey, zKey;
            if (this.independentExtruders) {
                let currentToolhead = this.stateMachines["toolhead"].getCurrentState().value;
                xKey = "xTool" + currentToolhead;
                yKey = "yTool" + currentToolhead;
                zKey = "zTool" + currentToolhead;
            }
            else {
                xKey = "x";
                yKey = "y";
                zKey = "z";
            }
            if (!this.stateMachines["x"].stateInserted && instruction.x !== null) {
                let currentXState = this.stateMachines[xKey].getCurrentState();
                let newXPosition = currentXState.position || 0;
                if (((instruction instanceof linear_move_1.default) && instruction.relativeX)
                    || currentXState.coordinateMode === enums_1.CoordinateModes.Relative) {
                    newXPosition += instruction.x;
                }
                else {
                    newXPosition = instruction.x;
                }
                this.stateMachines[xKey].insertState(new offset_axis_2.OffsetAxisState({
                    coordinateMode: currentXState.coordinateMode,
                    offset: currentXState.offset,
                    position: newXPosition
                }));
                this.stateMachines[xKey].stateInserted = true;
            }
            if (!this.stateMachines["y"].stateInserted && instruction.y !== null) {
                let currentYState = this.stateMachines[yKey].getCurrentState();
                let newYPosition = currentYState.position || 0;
                if (((instruction instanceof linear_move_1.default) && instruction.relativeY)
                    || currentYState.coordinateMode === enums_1.CoordinateModes.Relative) {
                    newYPosition += instruction.y;
                }
                else {
                    newYPosition = instruction.y;
                }
                this.stateMachines[yKey].insertState(new offset_axis_2.OffsetAxisState({
                    coordinateMode: currentYState.coordinateMode,
                    offset: currentYState.offset,
                    position: newYPosition
                }));
                this.stateMachines[yKey].stateInserted = true;
            }
            if (!this.stateMachines["feedrate"].stateInserted && instruction.feedrate !== null) {
                this.stateMachines["feedrate"].insertState(new non_negative_axis_1.NonNegativeAxisState({
                    position: instruction.feedrate
                }));
                this.stateMachines["feedrate"].stateInserted = true;
            }
            if (!this.stateMachines["extrusion"].stateInserted && instruction.extrusion !== null) {
                let currentEState = this.stateMachines["extrusion"].getCurrentState();
                let newEState = getNewExtrusionStateAfterMoveCommand(instruction, currentEState, this.volumetricExtrusion, this.filamentDiameter);
                this.stateMachines["extrusion"].insertState(newEState);
                this.stateMachines["extrusion"].stateInserted = true;
            }
            if (instruction instanceof linear_move_1.default) {
                if (!this.stateMachines["z"].stateInserted && instruction.z !== null) {
                    let currentZState = this.stateMachines[zKey].getCurrentState();
                    let newZPosition = currentZState.position || 0;
                    if (instruction.relativeZ || currentZState.coordinateMode === enums_1.CoordinateModes.Relative) {
                        newZPosition += instruction.z;
                    }
                    else {
                        newZPosition = instruction.z;
                    }
                    this.stateMachines[zKey].insertState(new offset_axis_2.OffsetAxisState({
                        coordinateMode: currentZState.coordinateMode,
                        offset: currentZState.offset,
                        position: newZPosition
                    }));
                    this.stateMachines[zKey].stateInserted = true;
                }
            }
        }
        if (instruction instanceof retract_1.default) {
            if (!this.stateMachines["extrusion"].stateInserted) {
                let currentEState = this.stateMachines["extrusion"].getCurrentState();
                let newEPosition;
                let newRetraction;
                if (instruction.isUnretract) {
                    newEPosition = currentEState.position + (currentEState.retractDistance + currentEState.unretractExtraLength);
                    newRetraction = currentEState.retraction - (currentEState.retractDistance + currentEState.unretractExtraLength);
                }
                else {
                    newEPosition = currentEState.position - currentEState.retractDistance;
                    newRetraction = currentEState.retraction + currentEState.retractDistance;
                }
                this.stateMachines["extrusion"].insertState(new extrusion_axis_1.ExtrusionAxisState({
                    coordinateMode: currentEState.coordinateMode,
                    retractDistance: currentEState.retractDistance,
                    unretractExtraLength: currentEState.unretractExtraLength,
                    position: newEPosition,
                    totalDispensed: currentEState.totalDispensed,
                    retraction: newRetraction,
                }));
                this.stateMachines["extrusion"].stateInserted = true;
            }
        }
        if ((instruction instanceof set_tool_offset_1.default) || (instruction instanceof offset_axis_1.default)) {
            let xKey, yKey, zKey;
            if (this.independentExtruders) {
                let currentToolhead = this.stateMachines["toolhead"].getCurrentState().value;
                xKey = "xTool" + (instruction instanceof set_tool_offset_1.default ? instruction.toolhead : currentToolhead);
                yKey = "yTool" + (instruction instanceof set_tool_offset_1.default ? instruction.toolhead : currentToolhead);
                zKey = "zTool" + (instruction instanceof set_tool_offset_1.default ? instruction.toolhead : currentToolhead);
            }
            else {
                xKey = "x";
                yKey = "y";
                zKey = "z";
            }
            if (!this.stateMachines[xKey].stateInserted && instruction.x !== null) {
                let currentXState = this.stateMachines["x"].getCurrentState();
                this.stateMachines[xKey].insertState(new offset_axis_2.OffsetAxisState({
                    coordinateMode: currentXState.coordinateMode,
                    offset: instruction.x,
                    position: currentXState.position - instruction.x
                }));
                this.stateMachines[xKey].stateInserted = true;
            }
            if (!this.stateMachines[yKey].stateInserted && instruction.y !== null) {
                let currentYState = this.stateMachines["y"].getCurrentState();
                this.stateMachines[yKey].insertState(new offset_axis_2.OffsetAxisState({
                    coordinateMode: currentYState.coordinateMode,
                    offset: instruction.y,
                    position: currentYState.position - instruction.y
                }));
                this.stateMachines[yKey].stateInserted = true;
            }
            if (!this.stateMachines[zKey].stateInserted && instruction.z !== null) {
                let currentZState = this.stateMachines["z"].getCurrentState();
                this.stateMachines[zKey].insertState(new offset_axis_2.OffsetAxisState({
                    coordinateMode: currentZState.coordinateMode,
                    offset: instruction.z,
                    position: currentZState.position - instruction.z
                }));
                this.stateMachines[zKey].stateInserted = true;
            }
        }
        if (instruction instanceof home_1.default) {
            if (!this.stateMachines["x"].stateInserted && instruction.x) {
                let currentXState = this.stateMachines["x"].getCurrentState();
                this.stateMachines["x"].insertState(new offset_axis_2.OffsetAxisState({
                    coordinateMode: currentXState.coordinateMode,
                    offset: currentXState.offset,
                    position: null
                }));
                this.stateMachines["x"].stateInserted = true;
            }
            if (!this.stateMachines["y"].stateInserted && instruction.y) {
                let currentYState = this.stateMachines["y"].getCurrentState();
                this.stateMachines["y"].insertState(new offset_axis_2.OffsetAxisState({
                    coordinateMode: currentYState.coordinateMode,
                    offset: currentYState.offset,
                    position: null
                }));
                this.stateMachines["y"].stateInserted = true;
            }
            if (!this.stateMachines["z"].stateInserted && instruction.z) {
                let currentZState = this.stateMachines["z"].getCurrentState();
                this.stateMachines["z"].insertState(new offset_axis_2.OffsetAxisState({
                    coordinateMode: currentZState.coordinateMode,
                    offset: currentZState.offset,
                    position: null
                }));
                this.stateMachines["z"].stateInserted = true;
            }
        }
        if (instruction instanceof set_coordinate_mode_1.default) {
            if (instruction.xyz !== enums_1.CoordinateModes.None) {
                if (this.independentExtruders) {
                    for (let i = 0; i < this.toolheadCount; i++) {
                        if (!this.stateMachines["xTool" + i].stateInserted
                            && !this.stateMachines["yTool" + i].stateInserted
                            && !this.stateMachines["zTool" + i].stateInserted) {
                            let currentXState = this.stateMachines["xTool" + i].getCurrentState();
                            let currentYState = this.stateMachines["yTool" + i].getCurrentState();
                            let currentZState = this.stateMachines["zTool" + i].getCurrentState();
                            this.stateMachines["xTool" + i].insertState(new offset_axis_2.OffsetAxisState({
                                coordinateMode: instruction.xyz,
                                offset: currentXState.offset,
                                position: currentXState.position
                            }));
                            this.stateMachines["yTool" + i].insertState(new offset_axis_2.OffsetAxisState({
                                coordinateMode: instruction.xyz,
                                offset: currentYState.offset,
                                position: currentYState.position
                            }));
                            this.stateMachines["zTool" + i].insertState(new offset_axis_2.OffsetAxisState({
                                coordinateMode: instruction.xyz,
                                offset: currentZState.offset,
                                position: currentZState.position
                            }));
                            this.stateMachines["xTool" + i].stateInserted = true;
                            this.stateMachines["yTool" + i].stateInserted = true;
                            this.stateMachines["zTool" + i].stateInserted = true;
                        }
                    }
                }
                else {
                    if (!this.stateMachines["x"].stateInserted
                        && !this.stateMachines["y"].stateInserted
                        && !this.stateMachines["z"].stateInserted) {
                        let currentXState = this.stateMachines["x"].getCurrentState();
                        let currentYState = this.stateMachines["y"].getCurrentState();
                        let currentZState = this.stateMachines["z"].getCurrentState();
                        this.stateMachines["x"].insertState(new offset_axis_2.OffsetAxisState({
                            coordinateMode: instruction.xyz,
                            offset: currentXState.offset,
                            position: currentXState.position
                        }));
                        this.stateMachines["y"].insertState(new offset_axis_2.OffsetAxisState({
                            coordinateMode: instruction.xyz,
                            offset: currentYState.offset,
                            position: currentYState.position
                        }));
                        this.stateMachines["z"].insertState(new offset_axis_2.OffsetAxisState({
                            coordinateMode: instruction.xyz,
                            offset: currentZState.offset,
                            position: currentZState.position
                        }));
                        this.stateMachines["x"].stateInserted = true;
                        this.stateMachines["y"].stateInserted = true;
                        this.stateMachines["z"].stateInserted = true;
                    }
                }
            }
            if (!this.stateMachines["extrusion"].stateInserted && instruction.extrusion !== enums_1.CoordinateModes.None) {
                let currentEState = this.stateMachines["extrusion"].getCurrentState();
                this.stateMachines["extrusion"].insertState(new extrusion_axis_1.ExtrusionAxisState({
                    coordinateMode: instruction.extrusion,
                    retractDistance: currentEState.retractDistance,
                    unretractExtraLength: currentEState.unretractExtraLength,
                    position: currentEState.position,
                    totalDispensed: currentEState.totalDispensed,
                    retraction: currentEState.retraction,
                }));
                this.stateMachines["extrusion"].stateInserted = true;
            }
        }
        if (instruction instanceof set_position_1.default) {
            let xKey, yKey, zKey;
            if (this.independentExtruders) {
                let currentToolhead = this.stateMachines["toolhead"].getCurrentState().value;
                xKey = "xTool" + currentToolhead;
                yKey = "yTool" + currentToolhead;
                zKey = "zTool" + currentToolhead;
            }
            else {
                xKey = "x";
                yKey = "y";
                zKey = "z";
            }
            if (!this.stateMachines[xKey].stateInserted && instruction.x !== null) {
                let currentXState = this.stateMachines["x"].getCurrentState();
                this.stateMachines[xKey].insertState(new offset_axis_2.OffsetAxisState({
                    coordinateMode: currentXState.coordinateMode,
                    offset: currentXState.offset,
                    position: instruction.x
                }));
                this.stateMachines[xKey].stateInserted = true;
            }
            if (!this.stateMachines[yKey].stateInserted && instruction.y !== null) {
                let currentYState = this.stateMachines["y"].getCurrentState();
                this.stateMachines[yKey].insertState(new offset_axis_2.OffsetAxisState({
                    coordinateMode: currentYState.coordinateMode,
                    offset: currentYState.offset,
                    position: instruction.y
                }));
                this.stateMachines[yKey].stateInserted = true;
            }
            if (!this.stateMachines[zKey].stateInserted && instruction.z !== null) {
                let currentZState = this.stateMachines["z"].getCurrentState();
                this.stateMachines[zKey].insertState(new offset_axis_2.OffsetAxisState({
                    coordinateMode: currentZState.coordinateMode,
                    offset: currentZState.offset,
                    position: instruction.z
                }));
                this.stateMachines[zKey].stateInserted = true;
            }
            if (!this.stateMachines["extrusion"].stateInserted && instruction.extrusion !== null) {
                let currentEState = this.stateMachines["extrusion"].getCurrentState();
                this.stateMachines["extrusion"].insertState(new extrusion_axis_1.ExtrusionAxisState({
                    coordinateMode: currentEState.coordinateMode,
                    retractDistance: currentEState.retractDistance,
                    unretractExtraLength: currentEState.unretractExtraLength,
                    position: instruction.extrusion,
                    totalDispensed: currentEState.totalDispensed,
                    retraction: currentEState.retraction,
                }));
                this.stateMachines["extrusion"].stateInserted = true;
            }
        }
        if (instruction instanceof set_toolhead_temperature_1.default) {
            if (!this.stateMachines["extruderTemp"].stateInserted) {
                let currentTempState = this.stateMachines["extruderTemp"].getCurrentState();
                this.stateMachines["extruderTemp"].insertState(new standby_axis_1.StandbyAxisState({
                    position: instruction.temperature,
                    standby: currentTempState.standby
                }));
                this.stateMachines["extruderTemp"].stateInserted = true;
            }
        }
        if (instruction instanceof set_fan_1.default) {
            if (!this.stateMachines["fan"].stateInserted) {
                this.stateMachines["fan"].insertState(new non_negative_axis_1.NonNegativeAxisState({
                    position: instruction.value
                }));
                this.stateMachines["fan"].stateInserted = true;
            }
        }
        if (instruction instanceof bed_standby_1.default) {
            if (!this.stateMachines["bedTemp"].stateInserted) {
                let currentBedState = this.stateMachines["bedTemp"].getCurrentState();
                this.stateMachines["bedTemp"].insertState(new standby_axis_1.StandbyAxisState({
                    position: currentBedState.position,
                    standby: instruction.exitStandby
                }));
                this.stateMachines["bedTemp"].stateInserted = true;
            }
        }
        if (instruction instanceof set_bed_temperature_1.default) {
            if (!this.stateMachines["bedTemp"].stateInserted) {
                this.stateMachines["bedTemp"].insertState(new standby_axis_1.StandbyAxisState({
                    position: instruction.temperature,
                    standby: false
                }));
                this.stateMachines["bedTemp"].stateInserted = true;
            }
        }
        if (instruction instanceof set_retract_length_1.default) {
            if (!this.stateMachines["extrusion"].stateInserted) {
                let currentEState = this.stateMachines["extrusion"].getCurrentState();
                this.stateMachines["extrusion"].insertState(new extrusion_axis_1.ExtrusionAxisState({
                    coordinateMode: currentEState.coordinateMode,
                    retractDistance: instruction.retractLength,
                    unretractExtraLength: instruction.unretractLengthOffset,
                    position: currentEState.position,
                    totalDispensed: currentEState.totalDispensed,
                    retraction: currentEState.position,
                }));
                this.stateMachines["extrusion"].stateInserted = true;
            }
        }
        if (instruction instanceof toolchange_1.default) {
            if (!this.stateMachines["toolhead"].stateInserted) {
                this.stateMachines["toolhead"].insertState(new integer_1.IntegerState({
                    value: instruction.toolhead
                }));
                this.stateMachines["toolhead"].stateInserted = true;
            }
        }
        if (!this.stateMachines["printState"].stateInserted && instruction.comment) {
            let currentPrintState = this.stateMachines["printState"].getCurrentState();
            let nextState = print_1.default.getNextState(currentPrintState, instruction);
            this.stateMachines["printState"].insertState(nextState);
            this.stateMachines["printState"].stateInserted = true;
        }
        super.executeNext(instruction);
    }
    toString() {
        return "RepRapEngine";
    }
}
exports.default = RepRapEngine;
function getNewExtrusionStateAfterMoveCommand(instruction, currentState, volumetric = false, filamentDiameter = 1.75) {
    let newEPosition = currentState.position || 0;
    let newTotalDispensed = currentState.totalDispensed;
    let newRetraction = currentState.retraction;
    if (currentState.coordinateMode === enums_1.CoordinateModes.Relative) {
        if (instruction.extrusion < 0) {
            // relative, negative extrusion
            newEPosition += instruction.extrusion;
            newRetraction -= instruction.extrusion;
        }
        else if (instruction.extrusion > 0) {
            // relative, positive extrusion
            newEPosition += instruction.extrusion;
            newRetraction = Math.max(0, currentState.retraction - instruction.extrusion);
            if (newRetraction === 0) {
                if (volumetric) {
                    newTotalDispensed += 4 * (instruction.extrusion - currentState.retraction)
                        / (Math.PI * Math.pow(filamentDiameter, 2));
                }
                else {
                    newTotalDispensed += instruction.extrusion - currentState.retraction;
                }
            }
        }
    }
    else {
        let positionDelta = instruction.extrusion - currentState.position;
        if (instruction.extrusion < currentState.position) {
            // absolute, negative extrusion
            newEPosition = instruction.extrusion;
            newRetraction -= positionDelta;
        }
        else if (instruction.extrusion > currentState.position) {
            // absolute, positive extrusion
            newEPosition = instruction.extrusion;
            newRetraction = Math.max(0, currentState.retraction - positionDelta);
            if (newRetraction === 0) {
                if (volumetric) {
                    newTotalDispensed += 4 * (positionDelta - currentState.retraction)
                        / (Math.PI * Math.pow(filamentDiameter, 2));
                }
                else {
                    newTotalDispensed += positionDelta - currentState.retraction;
                }
            }
        }
    }
    return new extrusion_axis_1.ExtrusionAxisState({
        coordinateMode: currentState.coordinateMode,
        retractDistance: currentState.retractDistance,
        unretractExtraLength: currentState.unretractExtraLength,
        position: newEPosition,
        totalDispensed: newTotalDispensed,
        retraction: newRetraction,
    });
}
exports.getNewExtrusionStateAfterMoveCommand = getNewExtrusionStateAfterMoveCommand;
/**
 * GCode-to-RaftInstruction translation functions
 */
function fromG0G1(line) {
    return new linear_move_1.default({
        x: line.x,
        y: line.y,
        z: line.z,
        extrusion: line.e,
        feedrate: line.f,
        isRapidMove: line.command === "G0",
        comment: line.comment
    });
}
function fromG2G3(line) {
    return new arc_move_1.default({
        clockwise: line.command === "G2",
        x: line.x,
        y: line.y,
        i: line.i,
        j: line.j,
        extrusion: line.e,
        feedrate: line.f,
        comment: line.comment
    });
}
function fromG4(line) {
    if (line.p !== undefined) {
        return new dwell_1.default({
            duration: line.p,
            comment: line.comment
        });
    }
    if (line.s !== undefined) {
        return new dwell_1.default({
            duration: line.s,
            useMilliseconds: false,
            comment: line.comment
        });
    }
    throw new invalid_instruction_1.default("No duration parameter supplied for dwell instruction (e.g. G4 P2000 or G4 S2)");
}
function fromG10G11(line) {
    if (line.command === "G10" && line.hasOwnProperty("p")) {
        return new set_tool_offset_1.default({
            toolhead: line.p,
            x: line.x,
            y: line.y,
            z: line.z,
            comment: line.comment
        });
    }
    return new retract_1.default({
        isUnretract: (line.command === "G11"),
        comment: line.comment
    });
}
function fromG20G21(line) {
    return new set_units_1.default({
        units: (line.command === "G20" ? enums_1.DistanceUnits.Inches : enums_1.DistanceUnits.Millimeters),
        comment: line.comment
    });
}
function fromG28(line) {
    if (line.x === undefined && line.y === undefined && line.z === undefined) {
        return new home_1.default({
            x: true,
            y: true,
            z: true,
            comment: line.comment
        });
    }
    return new home_1.default({
        x: (typeof line.x === "number") ? line.x : line.hasOwnProperty("x"),
        y: (typeof line.y === "number") ? line.y : line.hasOwnProperty("y"),
        z: (typeof line.z === "number") ? line.z : line.hasOwnProperty("z"),
        comment: line.comment
    });
}
function fromG29(line) {
    return new z_probe_1.default({
        original: line.original
    });
}
function fromG90(line) {
    return new set_coordinate_mode_1.default({
        xyz: enums_1.CoordinateModes.Absolute,
        comment: line.comment
    });
}
function fromG91(line) {
    return new set_coordinate_mode_1.default({
        xyz: enums_1.CoordinateModes.Relative,
        comment: line.comment
    });
}
function fromG92(line) {
    if (line.x === undefined && line.y === undefined && line.z === undefined && line.e === undefined) {
        return new set_position_1.default({
            x: 0,
            y: 0,
            z: 0,
            extrusion: 0,
            comment: line.comment
        });
    }
    return new set_position_1.default({
        x: line.x,
        y: line.y,
        z: line.z,
        extrusion: line.e,
        comment: line.comment
    });
}
function fromT(line) {
    let tool = parseInt(line.command.substr(1));
    return new toolchange_1.default({
        toolhead: tool,
        comment: line.comment
    });
}
exports.fromT = fromT;
function fromM0(line) {
    return new stop_1.default({
        keepHeatersActive: (line.hasOwnProperty("h") && !!line.h),
        comment: line.comment
    });
}
function fromM1(line) {
    return new sleep_1.default({
        comment: line.comment
    });
}
function fromM18(line) {
    if (line.x === undefined && line.y === undefined && line.z === undefined && line.e === undefined) {
        return new disable_stepper_motor_1.default({
            comment: line.comment
        });
    }
    return new disable_stepper_motor_1.default({
        x: line.hasOwnProperty("x"),
        y: line.hasOwnProperty("y"),
        z: line.hasOwnProperty("z"),
        e: line.hasOwnProperty("e"),
        comment: line.comment
    });
}
function fromM24(line) {
    return new start_sd_print_1.default({
        comment: line.comment
    });
}
function fromM25(line) {
    return new pause_sd_print_1.default({
        comment: line.comment
    });
}
function fromM82(line) {
    return new set_coordinate_mode_1.default({
        extrusion: enums_1.CoordinateModes.Absolute,
        comment: line.comment
    });
}
function fromM83(line) {
    return new set_coordinate_mode_1.default({
        extrusion: enums_1.CoordinateModes.Relative,
        comment: line.comment
    });
}
function fromM84(line) {
    return new stop_idle_hold_1.default({
        timeout: line.s,
        comment: line.comment
    });
}
function fromM104(line) {
    return new set_toolhead_temperature_1.default({
        toolhead: line.t,
        temperature: (line.s === undefined ? null : line.s),
        stabilize: false,
        comment: line.comment
    });
}
function fromM106(line) {
    if (line.s === undefined) {
        throw new invalid_instruction_1.default("No fan speed parameter supplied for set fan instruction (e.g. M106 S255)");
    }
    return new set_fan_1.default({
        isToggle: false,
        fanNumber: line.p,
        value: line.s,
        comment: line.comment
    });
}
function fromM107(line) {
    return new set_fan_1.default({
        isToggle: true,
        value: false,
        comment: line.comment
    });
}
function fromM109(line) {
    return new set_toolhead_temperature_1.default({
        toolhead: line.t,
        temperature: (line.s === undefined ? null : line.s),
        maxTargetTemperature: line.r,
        stabilize: true,
        comment: line.comment
    });
}
function fromM112(line) {
    return new emergency_stop_1.default({
        comment: line.comment
    });
}
function fromM114(line) {
    return new get_position_1.default({
        comment: line.comment
    });
}
function fromM116(line) {
    if (line.p === undefined) {
        return new stabilize_all_temperatures_1.default({
            comment: line.comment
        });
    }
    return new stabilize_toolhead_temperature_1.default({
        toolhead: line.p,
        comment: line.comment
    });
}
exports.fromM116 = fromM116;
function fromM117(line) {
    return new display_message_1.default({
        message: line.message,
        comment: line.comment
    });
}
exports.fromM117 = fromM117;
function fromM135(line) {
    return new set_pid_sample_interval_1.default({
        interval: line.s,
        comment: line.comment
    });
}
function fromM140(line) {
    if (line.s === undefined) {
        return new bed_standby_1.default({
            exitStandby: true,
            comment: line.comment
        });
    }
    return new set_bed_temperature_1.default({
        temperature: line.s,
        bedNumber: line.t,
        heaterNumber: line.h,
        stabilize: false,
        comment: line.comment
    });
}
function fromM144(line) {
    return new bed_standby_1.default({
        comment: line.comment
    });
}
function fromM190(line) {
    return new set_bed_temperature_1.default({
        temperature: line.s,
        maxTargetTemperature: line.r,
        stabilize: true,
        comment: line.comment
    });
}
function fromM201(line) {
    return new set_max_print_acceleration_1.default({
        x: line.x,
        y: line.y,
        z: line.z,
        extrusion: line.e,
        comment: line.comment,
    });
}
exports.fromM201 = fromM201;
function fromM203(line) {
    return new set_max_feedrate_1.default({
        x: line.x,
        y: line.y,
        z: line.z,
        extrusion: line.e,
        comment: line.comment,
    });
}
function fromM206(line) {
    return new offset_axis_1.default({
        x: line.x,
        y: line.y,
        z: line.z,
        comment: line.comment
    });
}
function fromM207(line) {
    return new set_retract_length_1.default({
        retractLength: line.s,
        unretractLengthOffset: line.r,
        retractFeedrate: line.f,
        unretractFeedrate: line.t,
        zLift: line.z,
        comment: line.comment
    });
}
function fromM208(line) {
    return new set_axis_travel_bound_1.default({
        isMaximum: (line.s !== 1),
        x: line.x,
        y: line.y,
        z: line.z,
        comment: line.comment
    });
}
function fromM220(line) {
    return new set_speed_override_1.default({
        percentage: line.s,
        comment: line.comment
    });
}
function fromM221(line) {
    return new set_extrusion_override_1.default({
        percentage: line.s,
        toolhead: line.d,
        comment: line.comment
    });
}
function fromM226(line) {
    return new pause_1.default({
        comment: line.comment
    });
}
function fromM300(line) {
    return new play_beep_1.default({
        frequency: line.s,
        duration: line.p,
        comment: line.comment
    });
}
exports.fromM300 = fromM300;
function fromM400(line) {
    return new finish_buffer_1.default({
        comment: line.comment
    });
}
function fromM564(line) {
    return new limit_axis_travel_1.default({
        enabled: line.s === 1,
        comment: line.comment
    });
}
function fromM566(line) {
    return new set_max_jerk_speed_1.default({
        x: line.x,
        y: line.y,
        z: line.z,
        extrusion: line.e,
        comment: line.comment
    });
}
/**
 * RaftInstruction-to-GCode translation functions
 */
function fromLinearMove(instruction) {
    return {
        command: instruction.isRapidMove ? "G0" : "G1",
        x: (instruction.x === null ? undefined : instruction.x),
        y: (instruction.y === null ? undefined : instruction.y),
        z: (instruction.z === null ? undefined : instruction.z),
        e: (instruction.extrusion === null ? undefined : instruction.extrusion),
        f: (instruction.feedrate === null ? undefined : instruction.feedrate),
        comment: instruction.comment
    };
}
function fromArcMove(instruction) {
    return {
        command: instruction.clockwise ? "G2" : "G3",
        x: (instruction.x === null ? undefined : instruction.x),
        y: (instruction.y === null ? undefined : instruction.y),
        i: (instruction.i === null ? undefined : instruction.i),
        j: (instruction.j === null ? undefined : instruction.j),
        e: (instruction.extrusion === null ? undefined : instruction.extrusion),
        f: (instruction.feedrate === null ? undefined : instruction.feedrate),
        comment: instruction.comment
    };
}
function fromDwell(instruction) {
    if (instruction.useMilliseconds) {
        return {
            command: "G4",
            p: instruction.duration,
            comment: instruction.comment
        };
    }
    else {
        return {
            command: "G4",
            s: instruction.duration,
            comment: instruction.comment
        };
    }
}
function fromSetToolOffset(instruction) {
    return {
        command: "G10",
        p: (instruction.toolhead === null ? undefined : instruction.toolhead),
        x: (instruction.x === null ? undefined : instruction.x),
        y: (instruction.y === null ? undefined : instruction.y),
        z: (instruction.z === null ? undefined : instruction.z),
        comment: instruction.comment
    };
}
function fromRetract(instruction) {
    return {
        command: instruction.isUnretract ? "G11" : "G10",
        comment: instruction.comment
    };
}
function fromSetUnits(instruction) {
    return {
        command: instruction.units === enums_1.DistanceUnits.Inches ? "G20" : "G21",
        comment: instruction.comment
    };
}
function fromHome(instruction) {
    if (instruction.x === true && instruction.y === true && instruction.z === true) {
        return {
            command: "G28",
            comment: instruction.comment
        };
    }
    return {
        command: "G28",
        x: (instruction.x === false ? undefined : (instruction.x === true ? null : instruction.x)),
        y: (instruction.y === false ? undefined : (instruction.y === true ? null : instruction.y)),
        z: (instruction.z === false ? undefined : (instruction.z === true ? null : instruction.z)),
        comment: instruction.comment
    };
}
function fromZProbe(instruction) {
    return {
        original: instruction.original,
        comment: instruction.comment
    };
}
function fromSetCoordinateMode(instruction) {
    if (instruction.xyz === enums_1.CoordinateModes.None) {
        // command to set extrusion coordinate mode
        return {
            command: (instruction.extrusion === enums_1.CoordinateModes.Absolute ? "M82" : "M83"),
            comment: instruction.comment
        };
    }
    else {
        // command to set X/Y/Z coordinate mode
        return {
            command: (instruction.xyz === enums_1.CoordinateModes.Absolute ? "G90" : "G91"),
            comment: instruction.comment
        };
    }
}
function fromSetPosition(instruction) {
    if (instruction.x === null && instruction.y === null && instruction.z === null && instruction.extrusion === null) {
        return {
            command: "G92",
            comment: instruction.comment
        };
    }
    return {
        command: "G92",
        x: (instruction.x === null ? undefined : instruction.x),
        y: (instruction.y === null ? undefined : instruction.y),
        z: (instruction.z === null ? undefined : instruction.z),
        e: (instruction.extrusion === null ? undefined : instruction.extrusion),
        comment: instruction.comment
    };
}
function fromToolChange(instruction) {
    return {
        command: "T" + instruction.toolhead,
        comment: instruction.comment
    };
}
exports.fromToolChange = fromToolChange;
function fromStop(instruction) {
    if (instruction.keepHeatersActive === null) {
        return {
            command: "M0",
            comment: instruction.comment
        };
    }
    return {
        command: "M0",
        h: instruction.keepHeatersActive ? 1 : 0,
        comment: instruction.comment
    };
}
function fromSleep(instruction) {
    return {
        command: "M1",
        comment: instruction.comment
    };
}
function fromDisableStepperMotor(instruction) {
    if (instruction.x === null && instruction.y === null && instruction.z === null
        && instruction.a === null && instruction.b === null && instruction.e === null) {
        return {
            command: "M18",
            comment: instruction.comment
        };
    }
    return {
        command: "M18",
        x: (instruction.x === null ? undefined : 0),
        y: (instruction.y === null ? undefined : 0),
        z: (instruction.z === null ? undefined : 0),
        a: (instruction.a === null ? undefined : 0),
        b: (instruction.b === null ? undefined : 0),
        e: (instruction.e === null ? undefined : 0),
        comment: instruction.comment
    };
}
function fromStartSDPrint(instruction) {
    return {
        command: "M24",
        comment: instruction.comment
    };
}
function fromPauseSDPrint(instruction) {
    return {
        command: "M25",
        comment: instruction.comment
    };
}
function fromStopIdleHold(instruction) {
    return {
        command: "M84",
        s: (instruction.timeout === null ? undefined : instruction.timeout),
        comment: instruction.comment
    };
}
function fromSetToolheadTemperature(instruction) {
    if (instruction.stabilize) {
        return {
            command: "M109",
            t: (instruction.toolhead === null ? undefined : instruction.toolhead),
            s: (instruction.temperature === null ? undefined : instruction.temperature),
            r: (instruction.maxTargetTemperature === null ? undefined : instruction.maxTargetTemperature),
            comment: instruction.comment
        };
    }
    else {
        return {
            command: "M104",
            t: (instruction.toolhead === null ? undefined : instruction.toolhead),
            s: (instruction.temperature === null ? undefined : instruction.temperature),
            comment: instruction.comment
        };
    }
}
function fromSetFan(instruction) {
    if (instruction.isToggle) {
        return {
            command: "M107",
            comment: instruction.comment
        };
    }
    return {
        command: "M106",
        p: (instruction.fanNumber === null ? undefined : instruction.fanNumber),
        s: instruction.value,
        comment: instruction.comment
    };
}
function fromEmergencyStop(instruction) {
    return {
        command: "M112",
        comment: instruction.comment
    };
}
function fromGetPosition(instruction) {
    return {
        command: "M114",
        comment: instruction.comment
    };
}
function fromStabilizeTemperature(instruction) {
    if (instruction instanceof stabilize_toolhead_temperature_1.default) {
        return {
            command: "M116",
            p: instruction.toolhead,
            comment: instruction.comment
        };
    }
    return {
        command: "M116",
        comment: instruction.comment
    };
}
function fromDisplayMessage(instruction) {
    return {
        command: "M117",
        message: instruction.message,
        comment: instruction.comment
    };
}
function fromSetPIDSampleInterval(instruction) {
    return {
        command: "M135",
        s: instruction.interval,
        comment: instruction.comment
    };
}
function fromBedStandby(instruction) {
    if (instruction.exitStandby) {
        return {
            command: "M140",
            comment: instruction.comment
        };
    }
    return {
        command: "M144",
        comment: instruction.comment
    };
}
function fromSetBedTemperature(instruction) {
    if (instruction.stabilize) {
        return {
            command: "M190",
            s: (instruction.temperature === null ? undefined : instruction.temperature),
            r: (instruction.maxTargetTemperature === null ? undefined : instruction.maxTargetTemperature),
            comment: instruction.comment
        };
    }
    else {
        return {
            command: "M140",
            s: instruction.temperature,
            t: (instruction.bedNumber === null ? undefined : instruction.bedNumber),
            h: (instruction.heaterNumber === null ? undefined : instruction.heaterNumber),
            comment: instruction.comment
        };
    }
}
function fromSetMaxPrintAcceleration(instruction) {
    return {
        command: "M201",
        x: (instruction.x === null ? undefined : instruction.x),
        y: (instruction.y === null ? undefined : instruction.y),
        z: (instruction.z === null ? undefined : instruction.z),
        e: (instruction.extrusion === null ? undefined : instruction.extrusion),
        comment: instruction.comment
    };
}
function fromSetMaxFeedrate(instruction) {
    return {
        command: "M203",
        x: (instruction.x === null ? undefined : instruction.x),
        y: (instruction.y === null ? undefined : instruction.y),
        z: (instruction.z === null ? undefined : instruction.z),
        e: (instruction.extrusion === null ? undefined : instruction.extrusion),
        comment: instruction.comment
    };
}
function fromOffsetAxis(instruction) {
    return {
        command: "M206",
        x: (instruction.x === null ? undefined : instruction.x),
        y: (instruction.y === null ? undefined : instruction.y),
        z: (instruction.z === null ? undefined : instruction.z),
        comment: instruction.comment
    };
}
function fromSetRetractLength(instruction) {
    return {
        command: "M207",
        s: (instruction.retractLength === null ? undefined : instruction.retractLength),
        r: (instruction.unretractLengthOffset === null ? undefined : instruction.unretractLengthOffset),
        f: (instruction.retractFeedrate === null ? undefined : instruction.retractFeedrate),
        t: (instruction.unretractFeedrate === null ? undefined : instruction.unretractFeedrate),
        z: (instruction.zLift === null ? undefined : instruction.zLift),
        comment: instruction.comment
    };
}
function fromSetAxisTravelBound(instruction) {
    return {
        command: "M208",
        s: instruction.isMaximum ? undefined : 1,
        x: (instruction.x === null ? undefined : instruction.x),
        y: (instruction.y === null ? undefined : instruction.y),
        z: (instruction.z === null ? undefined : instruction.z),
        comment: instruction.comment
    };
}
function fromSetSpeedOverride(instruction) {
    return {
        command: "M220",
        s: instruction.percentage,
        comment: instruction.comment
    };
}
function fromSetExtrusionOverride(instruction) {
    return {
        command: "M221",
        s: instruction.percentage,
        d: instruction.toolhead === null ? undefined : instruction.toolhead,
        comment: instruction.comment
    };
}
function fromPause(instruction) {
    return {
        command: "M226",
        comment: instruction.comment
    };
}
function fromPlayBeep(instruction) {
    return {
        command: "M300",
        s: instruction.frequency,
        p: instruction.duration,
        comment: instruction.comment
    };
}
function fromFinishBuffer(instruction) {
    return {
        command: "M400",
        comment: instruction.comment
    };
}
function fromLimitAxisTravel(instruction) {
    return {
        command: "M564",
        s: instruction.enabled ? 1 : 0,
        comment: instruction.comment
    };
}
function fromSetMaxJerkSpeed(instruction) {
    return {
        command: "M566",
        x: (instruction.x === null ? undefined : instruction.x),
        y: (instruction.y === null ? undefined : instruction.y),
        z: (instruction.z === null ? undefined : instruction.z),
        e: (instruction.extrusion === null ? undefined : instruction.extrusion),
        comment: instruction.comment
    };
}
function fromOStartMulticolor(instruction) {
    return {
        command: "",
        original: "O1 D" + instruction.filename + " D" + hex_1.floatToHexString(instruction.printLength),
        comment: instruction.comment
    };
}
function fromOSoftReset(instruction) {
    return {
        command: "O9",
        comment: instruction.comment
    };
}
function fromOVersion(instruction) {
    const version = (instruction.major * 10) + instruction.minor;
    return {
        command: "O21",
        d: hex_1.intToHexString(version, 4),
        comment: instruction.comment
    };
}
function fromOPrinterProfile(instruction) {
    return {
        command: "O22",
        d: instruction.id,
        comment: instruction.comment
    };
}
function fromOSlicerProfile(instruction) {
    return {
        command: "O23",
        d: instruction.id,
        comment: instruction.comment
    };
}
function fromOAdjustedPPM(instruction) {
    return {
        command: "O24",
        d: hex_1.intToHexString(instruction.adjustment, 4),
        comment: instruction.comment
    };
}
function fromOMaterialsUsed(instruction) {
    let original = "O25";
    for (let material of instruction.materials) {
        original += " D";
        if (material.index === 0) {
            original += "0";
        }
        else {
            original += hex_1.intToHexString(material.index, 1);
            original += hex_1.intToHexString(material.color[0], 2);
            original += hex_1.intToHexString(material.color[1], 2);
            original += hex_1.intToHexString(material.color[2], 2);
            original += material.name;
        }
    }
    return {
        command: "",
        original: original,
        comment: instruction.comment
    };
}
function fromOSpliceCount(instruction) {
    return {
        command: "O26",
        d: hex_1.intToHexString(instruction.count, 4),
        comment: instruction.comment
    };
}
function fromOPingCount(instruction) {
    return {
        command: "O27",
        d: hex_1.intToHexString(instruction.count, 4),
        comment: instruction.comment
    };
}
function fromOAlgorithmCount(instruction) {
    return {
        command: "O28",
        d: hex_1.intToHexString(instruction.count, 4),
        comment: instruction.comment
    };
}
function fromOHotSwapCount(instruction) {
    return {
        command: "O29",
        d: hex_1.intToHexString(instruction.count, 4),
        comment: instruction.comment
    };
}
function fromOSpliceData(instruction) {
    return {
        command: "",
        original: "O30 D" + instruction.drive + " D" + hex_1.floatToHexString(instruction.length),
        comment: instruction.comment
    };
}
function fromOPingData(instruction) {
    let original = "O31 D" + hex_1.floatToHexString(instruction.length);
    if (instruction.extrusion !== null) {
        original += " D" + hex_1.floatToHexString(instruction.extrusion);
    }
    return {
        command: "",
        original: original,
        comment: instruction.comment
    };
}
function fromOAlgorithmData(instruction) {
    const original = "O32 D" + instruction.ingoing.toString() + instruction.outgoing.toString()
        + " D" + hex_1.int16ToHexString(Math.round(instruction.heat))
        + " D" + hex_1.int16ToHexString(Math.round(instruction.compression))
        + " D" + hex_1.int16ToHexString(Math.round(instruction.cooling));
    return {
        command: "",
        original: original,
        comment: instruction.comment
    };
}
function fromOHotSwapData(instruction) {
    const original = "O33 D" + hex_1.floatToHexString(instruction.drive)
        + " D" + hex_1.floatToHexString(instruction.length)
        + " D" + instruction.materialIndex;
    return {
        command: "",
        original: original,
        comment: instruction.comment
    };
}
//# sourceMappingURL=reprap.js.map