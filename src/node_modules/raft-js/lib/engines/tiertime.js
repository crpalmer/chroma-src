"use strict";
/**
 * @module RaftEngine
 */ /** */
Object.defineProperty(exports, "__esModule", { value: true });
const reprap_1 = require("./reprap");
const linear_move_1 = require("../instructions/linear-move");
const enums_1 = require("../enums");
const extrusion_axis_1 = require("../state-machines/extrusion-axis");
const arc_move_1 = require("../instructions/arc-move");
const empty_1 = require("../instructions/empty");
const base_1 = require("./base");
class TiertimeEngine extends reprap_1.default {
    constructor(options) {
        options.volumetricExtrusion = false;
        super(options);
        this.extruderStepsPerMM = options.extruderStepsPerMM;
    }
    clone() {
        let copy = new TiertimeEngine({
            toolheadCount: this.toolheadCount,
            independentExtruders: this.independentExtruders,
            volumetricExtrusion: this.volumetricExtrusion,
            defaultHomeDirectionMax: this.defaultHomeDirectionMax,
            filamentDiameter: this.filamentDiameter,
            initialXYZCoordinateMode: this.stateMachines["x"].getCurrentState().coordinateMode,
            initialExtrusionCoordinateMode: this.stateMachines["extrusion"].getCurrentState().coordinateMode,
            extruderStepsPerMM: this.extruderStepsPerMM
        });
        this.copyStateMachinesTo(copy);
        return copy;
    }
    toRaftInstruction(line) {
        if (!line.command) {
            return new empty_1.default({
                comment: line.comment
            });
        }
        if (line.command === "G28")
            return base_1.unknownInstruction(line, this.config);
        return super.toRaftInstruction(line);
    }
    executeNext(instruction) {
        if (instruction instanceof linear_move_1.default || instruction instanceof arc_move_1.default) {
            if (!this.stateMachines["extrusion"].stateInserted && instruction.extrusion !== null) {
                let currentEState = this.stateMachines["extrusion"].getCurrentState();
                let newEState = getNewExtrusionStateAfterMoveCommand(instruction, currentEState, this.extruderStepsPerMM);
                this.stateMachines["extrusion"].insertState(newEState);
                this.stateMachines["extrusion"].stateInserted = true;
            }
        }
        super.executeNext(instruction);
    }
    toString() {
        return "TiertimeEngine";
    }
}
exports.default = TiertimeEngine;
function getNewExtrusionStateAfterMoveCommand(instruction, currentState, extruderStepsPerMM) {
    let newEPosition = currentState.position || 0;
    let newTotalDispensed = currentState.totalDispensed;
    let newRetraction = currentState.retraction;
    if (currentState.coordinateMode === enums_1.CoordinateModes.Relative) {
        if (instruction.extrusion < 0) {
            // relative, negative extrusion
            newEPosition += instruction.extrusion;
            newRetraction -= instruction.extrusion;
        }
        else if (instruction.extrusion > 0) {
            // relative, positive extrusion
            newEPosition += instruction.extrusion;
            newRetraction = Math.max(0, (currentState.retraction - instruction.extrusion));
            if (newRetraction === 0) {
                newTotalDispensed += (instruction.extrusion - currentState.retraction) / extruderStepsPerMM;
            }
        }
    }
    else {
        let positionDelta = instruction.extrusion - currentState.position;
        if (instruction.extrusion < currentState.position) {
            // absolute, negative extrusion
            newEPosition = instruction.extrusion;
            newRetraction -= positionDelta;
        }
        else if (instruction.extrusion > currentState.position) {
            // absolute, positive extrusion
            newEPosition = instruction.extrusion;
            newRetraction = Math.max(0, (currentState.retraction - positionDelta));
            if (newRetraction === 0) {
                newTotalDispensed += (positionDelta - currentState.retraction) / extruderStepsPerMM;
            }
        }
    }
    return new extrusion_axis_1.ExtrusionAxisState({
        coordinateMode: currentState.coordinateMode,
        retractDistance: currentState.retractDistance,
        unretractExtraLength: currentState.unretractExtraLength,
        position: newEPosition,
        totalDispensed: newTotalDispensed,
        retraction: newRetraction,
    });
}
exports.getNewExtrusionStateAfterMoveCommand = getNewExtrusionStateAfterMoveCommand;
//# sourceMappingURL=tiertime.js.map