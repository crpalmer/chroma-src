"use strict";
/**
 * @module RaftEngine
 */ /** */
Object.defineProperty(exports, "__esModule", { value: true });
const invalid_instruction_1 = require("../errors/invalid-instruction");
const util_1 = require("util");
const unknown_1 = require("../instructions/unknown");
class RaftEngine {
    constructor(options) {
        this.config = {
            skipInvalidInstructions: false
        };
        if (!util_1.isNullOrUndefined(options.skipInvalidInstructions)) {
            this.config.skipInvalidInstructions = options.skipInvalidInstructions;
        }
        this.stateMachines = {};
    }
    /**
     * FINAL
     */
    copyStateMachinesTo(engine) {
        let keys = Object.keys(this.stateMachines);
        for (let key of keys) {
            engine.stateMachines[key] = this.stateMachines[key].clone();
        }
        engine.config.skipInvalidInstructions = this.config.skipInvalidInstructions;
    }
    /**
     * FINAL
     */
    getCurrentState() {
        let keys = Object.keys(this.stateMachines);
        let map = new Map();
        for (let key of keys) {
            map.set(key, this.stateMachines[key].getCurrentState());
        }
        return map;
    }
    toRaftInstruction(line) {
        return unknownInstruction(line, this.config);
    }
    toOutputInstruction(instruction) {
        if (instruction instanceof unknown_1.default) {
            return {
                original: instruction.original,
                comment: instruction.comment
            };
        }
        return {
            comment: instruction.comment
        };
    }
    /**
     * FINAL
     */
    needsExecuteForNextInstruction() {
        let keys = Object.keys(this.stateMachines);
        let anyStateMachine = this.stateMachines[keys[0]];
        return anyStateMachine.futureIsEmpty();
    }
    executeNext(instruction) {
        let keys = Object.keys(this.stateMachines);
        for (let key of keys) {
            if (!this.stateMachines[key].stateInserted) {
                this.stateMachines[key].insertCurrentState();
            }
            this.stateMachines[key].stateInserted = false;
        }
    }
    /**
     * FINAL
     */
    stepForward() {
        let keys = Object.keys(this.stateMachines);
        for (let key of keys) {
            this.stateMachines[key].stepForward();
        }
    }
    /**
     * FINAL
     */
    stepBackward() {
        let keys = Object.keys(this.stateMachines);
        for (let key of keys) {
            this.stateMachines[key].stepBackward();
        }
    }
    /**
     * FINAL
     */
    invalidateFuture() {
        let keys = Object.keys(this.stateMachines);
        for (let key of keys) {
            this.stateMachines[key].invalidateFuture();
        }
    }
    toString() {
        return "RaftEngine";
    }
}
function unknownInstruction(line, config) {
    if (config.skipInvalidInstructions) {
        return new unknown_1.default({
            original: line.original
        });
    }
    else {
        throw new invalid_instruction_1.default("Invalid/unknown instruction encountered", line.original);
    }
}
exports.unknownInstruction = unknownInstruction;
exports.default = RaftEngine;
//# sourceMappingURL=base.js.map