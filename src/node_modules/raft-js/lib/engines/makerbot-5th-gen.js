"use strict";
/**
 * @module RaftEngine
 */ /** */
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = require("./base");
const linear_move_1 = require("../instructions/linear-move");
const set_fan_1 = require("../instructions/set-fan");
const set_toolhead_temperature_1 = require("../instructions/set-toolhead-temperature");
const invalid_instruction_1 = require("../errors/invalid-instruction");
const empty_1 = require("../instructions/empty");
const offset_axis_1 = require("../state-machines/offset-axis");
const enums_1 = require("../enums");
const extrusion_axis_1 = require("../state-machines/extrusion-axis");
const non_negative_axis_1 = require("../state-machines/non-negative-axis");
const standby_axis_1 = require("../state-machines/standby-axis");
const util_1 = require("util");
const print_1 = require("../state-machines/print");
const math_1 = require("../common/math");
class Makerbot5thGenEngine extends base_1.default {
    constructor(options) {
        super(options);
        this.lastX = 0;
        this.lastY = 0;
        this.lastZ = 0;
        this.lastFeedrate = 0;
        this.stateMachines["x"] = new offset_axis_1.default(new offset_axis_1.OffsetAxisState({
            coordinateMode: options.initialXYZCoordinateMode,
            position: null,
            offset: 0
        }));
        this.stateMachines["y"] = new offset_axis_1.default(new offset_axis_1.OffsetAxisState({
            coordinateMode: options.initialXYZCoordinateMode,
            position: null,
            offset: 0
        }));
        this.stateMachines["z"] = new offset_axis_1.default(new offset_axis_1.OffsetAxisState({
            coordinateMode: options.initialXYZCoordinateMode,
            position: null,
            offset: 0
        }));
        this.stateMachines["extrusion"] = new extrusion_axis_1.default(new extrusion_axis_1.ExtrusionAxisState({
            coordinateMode: options.initialExtrusionCoordinateMode,
            position: null,
            totalDispensed: 0,
            retraction: 0,
            retractDistance: null,
            unretractExtraLength: null
        }));
        this.stateMachines["feedrate"] = new non_negative_axis_1.default(new non_negative_axis_1.NonNegativeAxisState({
            position: null
        }));
        this.stateMachines["extruderTemp"] = new standby_axis_1.default(new standby_axis_1.StandbyAxisState({
            position: null,
            standby: true
        }));
        this.stateMachines["fan"] = new non_negative_axis_1.default(new non_negative_axis_1.NonNegativeAxisState({
            position: null
        }));
        this.stateMachines["printState"] = new print_1.default(new print_1.PrintState({
            value: util_1.isNullOrUndefined(options.initialPrintState) ? enums_1.PrintStates.None : options.initialPrintState
        }));
    }
    clone() {
        let copy = new Makerbot5thGenEngine({
            initialXYZCoordinateMode: this.stateMachines["x"].getCurrentState().coordinateMode,
            initialExtrusionCoordinateMode: this.stateMachines["extrusion"].getCurrentState().coordinateMode
        });
        this.copyStateMachinesTo(copy);
        return copy;
    }
    toRaftInstruction(line) {
        switch (line.command.function) {
            case "move":
                return fromJSONMove(line);
            case "comment":
                return fromJSONComment(line);
            case "set_toolhead_temperature":
                return fromJSONSetToolheadTemperature(line);
            case "fan_duty":
                return fromJSONFanDuty(line);
            case "toggle_fan":
                return fromJSONToggleFan(line);
        }
        if (this.config.skipInvalidInstructions) {
            return super.toRaftInstruction(line);
        }
        else {
            throw new invalid_instruction_1.default("Unknown instruction encountered", line.command.function);
        }
    }
    toOutputInstruction(instruction) {
        if (instruction instanceof linear_move_1.default)
            return fromLinearMove(instruction, this);
        if (instruction instanceof empty_1.default)
            return fromEmpty(instruction);
        if (instruction instanceof set_toolhead_temperature_1.default)
            return fromSetToolheadTemperature(instruction);
        if (instruction instanceof set_fan_1.default)
            return fromSetFan(instruction);
        return null;
    }
    executeNext(instruction) {
        if (instruction instanceof linear_move_1.default) {
            if (!this.stateMachines["x"].stateInserted && instruction.x !== null) {
                let currentXState = this.stateMachines["x"].getCurrentState();
                let newXPosition = currentXState.position || 0;
                if (instruction.relativeX) {
                    newXPosition += instruction.x;
                }
                else {
                    newXPosition = instruction.x;
                }
                this.stateMachines["x"].insertState(new offset_axis_1.OffsetAxisState({
                    coordinateMode: currentXState.coordinateMode,
                    offset: currentXState.offset,
                    position: newXPosition
                }));
                this.stateMachines["x"].stateInserted = true;
            }
            if (!this.stateMachines["y"].stateInserted && instruction.y !== null) {
                let currentYState = this.stateMachines["y"].getCurrentState();
                let newYPosition = currentYState.position || 0;
                if (instruction.relativeY) {
                    newYPosition += instruction.y;
                }
                else {
                    newYPosition = instruction.y;
                }
                this.stateMachines["y"].insertState(new offset_axis_1.OffsetAxisState({
                    coordinateMode: currentYState.coordinateMode,
                    offset: currentYState.offset,
                    position: newYPosition
                }));
                this.stateMachines["y"].stateInserted = true;
            }
            if (!this.stateMachines["z"].stateInserted && instruction.z !== null) {
                let currentZState = this.stateMachines["z"].getCurrentState();
                let newZPosition = currentZState.position || 0;
                if (instruction.relativeZ) {
                    newZPosition += instruction.z;
                }
                else {
                    newZPosition = instruction.z;
                }
                this.stateMachines["z"].insertState(new offset_axis_1.OffsetAxisState({
                    coordinateMode: currentZState.coordinateMode,
                    offset: currentZState.offset,
                    position: newZPosition
                }));
                this.stateMachines["z"].stateInserted = true;
            }
            if (!this.stateMachines["feedrate"].stateInserted && instruction.feedrate !== null) {
                this.stateMachines["feedrate"].insertState(new non_negative_axis_1.NonNegativeAxisState({
                    position: instruction.feedrate
                }));
                this.stateMachines["feedrate"].stateInserted = true;
            }
            if (!this.stateMachines["extrusion"].stateInserted && instruction.extrusion !== null) {
                let currentEState = this.stateMachines["extrusion"].getCurrentState();
                let newEPosition = currentEState.position || 0;
                let newTotalDispensed = currentEState.totalDispensed;
                let newRetraction = currentEState.retraction;
                if (instruction.relativeExtrusion) {
                    if (instruction.extrusion < 0) {
                        // relative, negative extrusion
                        newEPosition += instruction.extrusion;
                        newRetraction -= instruction.extrusion;
                    }
                    else if (instruction.extrusion > 0) {
                        // relative, positive extrusion
                        newEPosition += instruction.extrusion;
                        newRetraction = Math.max(0, currentEState.retraction - instruction.extrusion);
                        if (newRetraction === 0) {
                            newTotalDispensed += instruction.extrusion - currentEState.retraction;
                        }
                    }
                }
                else {
                    let positionDelta = instruction.extrusion - currentEState.position;
                    if (instruction.extrusion < currentEState.position) {
                        // absolute, negative extrusion
                        newEPosition = instruction.extrusion;
                        newRetraction -= positionDelta;
                    }
                    else if (instruction.extrusion > currentEState.position) {
                        // absolute, positive extrusion
                        newEPosition = instruction.extrusion;
                        newRetraction = Math.max(0, currentEState.retraction - positionDelta);
                        if (newRetraction === 0) {
                            newTotalDispensed += positionDelta - currentEState.retraction;
                        }
                    }
                }
                this.stateMachines["extrusion"].insertState(new extrusion_axis_1.ExtrusionAxisState({
                    coordinateMode: currentEState.coordinateMode,
                    retractDistance: currentEState.retractDistance,
                    unretractExtraLength: currentEState.unretractExtraLength,
                    position: newEPosition,
                    totalDispensed: newTotalDispensed,
                    retraction: newRetraction,
                }));
                this.stateMachines["extrusion"].stateInserted = true;
            }
        }
        if (instruction instanceof set_toolhead_temperature_1.default) {
            if (!this.stateMachines["extruderTemp"].stateInserted) {
                let currentTempState = this.stateMachines["extruderTemp"].getCurrentState();
                this.stateMachines["extruderTemp"].insertState(new standby_axis_1.StandbyAxisState({
                    position: instruction.temperature,
                    standby: currentTempState.standby
                }));
                this.stateMachines["extruderTemp"].stateInserted = true;
            }
        }
        if (instruction instanceof set_fan_1.default) {
            if (!this.stateMachines["fan"].stateInserted) {
                this.stateMachines["fan"].insertState(new non_negative_axis_1.NonNegativeAxisState({
                    position: instruction.value
                }));
                this.stateMachines["fan"].stateInserted = true;
            }
        }
        super.executeNext(instruction);
    }
    toString() {
        return "MakerbotEngine";
    }
}
exports.default = Makerbot5thGenEngine;
/**
 * JSON-to-RaftInstruction translation functions
 */
function fromJSONMove(line) {
    return new linear_move_1.default({
        x: line.command.parameters.x,
        y: line.command.parameters.y,
        z: line.command.parameters.z,
        extrusion: line.command.parameters.a,
        relativeX: line.command.metadata.relative.x,
        relativeY: line.command.metadata.relative.y,
        relativeZ: line.command.metadata.relative.z,
        relativeExtrusion: line.command.metadata.relative.a,
        feedrate: line.command.parameters.feedrate * 60,
        isRapidMove: true
    });
}
function fromJSONComment(line) {
    return new empty_1.default({
        comment: line.command.parameters.comment
    });
}
function fromJSONSetToolheadTemperature(line) {
    return new set_toolhead_temperature_1.default({
        temperature: line.command.parameters.temperature,
        stabilize: true
    });
}
function fromJSONFanDuty(line) {
    return new set_fan_1.default({
        isToggle: false,
        value: line.command.parameters.value
    });
}
function fromJSONToggleFan(line) {
    return new set_fan_1.default({
        isToggle: true,
        value: line.command.parameters.value
    });
}
/**
 * RaftInstruction-to-GCode translation functions
 */
function fromLinearMove(instruction, _this) {
    if (instruction.x !== null)
        _this.lastX = instruction.x;
    if (instruction.y !== null)
        _this.lastY = instruction.y;
    if (instruction.z !== null)
        _this.lastZ = instruction.z;
    if (instruction.feedrate !== null)
        _this.lastFeedrate = instruction.feedrate;
    return {
        command: {
            "function": "move",
            parameters: {
                x: instruction.x === null ? _this.lastX : instruction.x,
                y: instruction.y === null ? _this.lastY : instruction.y,
                z: instruction.z === null ? _this.lastZ : instruction.z,
                a: instruction.extrusion === null ? 0 : instruction.extrusion,
                feedrate: instruction.feedrate === null ? (_this.lastFeedrate / 60) : (instruction.feedrate / 60),
            },
            metadata: {
                relative: {
                    x: instruction.relativeX || (_this.getCurrentState().get("x").coordinateMode === enums_1.CoordinateModes.Relative),
                    y: instruction.relativeY || (_this.getCurrentState().get("y").coordinateMode === enums_1.CoordinateModes.Relative),
                    z: instruction.relativeZ || (_this.getCurrentState().get("z").coordinateMode === enums_1.CoordinateModes.Relative),
                    a: instruction.relativeExtrusion || (_this.getCurrentState().get("extrusion").coordinateMode === enums_1.CoordinateModes.Relative),
                }
            },
            tags: []
        }
    };
}
function fromEmpty(instruction) {
    return null;
    // return {
    //     command: {
    //         "function": "comment",
    //         parameters: {
    //             comment: instruction.comment.replace("\"", "").trim()
    //         },
    //         metadata: {},
    //         tags: []
    //     }
    // };
}
function fromSetToolheadTemperature(instruction) {
    return {
        command: {
            "function": "set_toolhead_temperature",
            parameters: {
                temperature: instruction.temperature
            },
            metadata: {},
            tags: []
        }
    };
}
function fromSetFan(instruction) {
    if (instruction.isToggle) {
        return {
            command: {
                "function": "toggle_fan",
                parameters: {
                    value: !!instruction.value
                },
                metadata: {},
                tags: []
            }
        };
    }
    let value = instruction.value;
    if (value > 1) {
        value = math_1.roundTo(value / 255, 6);
    }
    return {
        command: {
            "function": "fan_duty",
            parameters: {
                value: value
            },
            metadata: {},
            tags: []
        }
    };
}
//# sourceMappingURL=makerbot-5th-gen.js.map