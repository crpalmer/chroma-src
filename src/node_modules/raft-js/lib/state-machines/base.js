"use strict";
/**
 * @module RaftStateMachine
 */ /** */
Object.defineProperty(exports, "__esModule", { value: true });
const stack_1 = require("../common/stack");
const bad_method_call_1 = require("../errors/bad-method-call");
class RaftState {
    constructor(params) { }
    clone() {
        return new RaftState({});
    }
    toString() {
        return "RaftState";
    }
}
exports.RaftState = RaftState;
class RaftStateMachine {
    constructor(initialState) {
        this.history = new stack_1.default();
        this.future = new stack_1.default();
        this.current = initialState;
        this.stateInserted = false;
    }
    /**
     * FINAL
     */
    insertState(state) {
        this.history.push(this.current);
        this.current = state;
        this.future.clear();
    }
    /**
     * FINAL
     */
    insertCurrentState() {
        this.insertState(this.current);
    }
    /**
     * FINAL
     */
    stepForward() {
        if (this.future.isEmpty()) {
            throw new bad_method_call_1.default("Cannot step forward - future stack is empty");
        }
        this.history.push(this.current);
        this.current = this.future.pop();
    }
    /**
     * FINAL
     */
    stepBackward() {
        if (this.history.isEmpty()) {
            throw new bad_method_call_1.default("Cannot step backward - history stack is empty");
        }
        this.future.push(this.current);
        this.current = this.history.pop();
    }
    /**
     * FINAL
     */
    invalidateFuture() {
        this.future.clear();
    }
    futureIsEmpty() {
        return this.future.isEmpty();
    }
    /**
     * FINAL
     */
    getCurrentState() {
        return this.current.clone();
    }
    deepCopyStatesTo(other) {
        other.history = this.history.deepCopy();
        other.future = this.future.deepCopy();
        other.current = this.current.clone();
    }
    toString() {
        return "RaftStateMachine";
    }
}
exports.default = RaftStateMachine;
//# sourceMappingURL=base.js.map