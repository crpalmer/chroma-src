"use strict";
/**
 * @module RaftStateMachine
 */ /** */
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("util");
const integer_1 = require("./integer");
const invalid_state_params_1 = require("../errors/invalid-state-params");
const enums_1 = require("../enums");
class PrintState extends integer_1.IntegerState {
    constructor(params) {
        if (util_1.isNullOrUndefined(params.value) || !(params.value in enums_1.PrintStates)) {
            throw new invalid_state_params_1.default("Invalid value parameter '" + params.value + "' supplied to PrintState");
        }
        super(params);
    }
    clone() {
        return new PrintState({
            value: this.value
        });
    }
    toString() {
        return "PrintState";
    }
}
exports.PrintState = PrintState;
class PrintStateMachine extends integer_1.default {
    constructor(initialState) {
        super(initialState);
    }
    insertState(state) {
        super.insertState(state);
    }
    clone() {
        let copy = new PrintStateMachine(this.current);
        this.deepCopyStatesTo(copy);
        return copy;
    }
    toString() {
        return "PrintStateMachine";
    }
    static getNextState(currentState, instruction) {
        /*
         * Simplify3D feature comments
         * - start sequence     N/A
         * - end sequence       layer end
         * - skirt              skirt
         * - raft               raft
         * - brim               brim
         * - support            support
         * - inner perimeter    inner perimeter
         * - outer perimeter    outer perimeter
         * - solid layer        solid layer
         * - infill             infill
         * - gap fill           gap fill
         *
         * Cura feature comments
         * - start sequence     N/A
         * - end sequence       N/A
         * - skirt              TYPE:SKIRT
         * - raft               RAFT
         *                      TYPE:SUPPORT
         * - brim               N/A
         * - support            TYPE:SUPPORT
         * - inner perimeter    TYPE:WALL-INNER
         * - outer perimeter    TYPE:WALL-OUTER
         * - solid layer        TYPE:SKIN
         * - infill             TYPE:FILL
         * - gap fill           N/A
         *
         * KISSlicer feature comments
         * - start sequence     *** G-code Prefix ***
         * - end sequence       *** G-code Postfix ***
         * - skirt              'Prime Pillar Path', 1.5 [feed mm/s], 30.0 [head mm/s]
         * - raft               'Raft Path', 1.6 [feed mm/s], 30.0 [head mm/s]
         *                      'Pillar Path', 6.3 [feed mm/s], 10.0 [head mm/s]
         * - brim               N/A
         * - support            'Support Path', 1.4 [feed mm/s], 50.0 [head mm/s]
         *                      'Support Interface Path', 1.4 [feed mm/s], 50.0 [head mm/s]
         * - inner perimeter    'Loop Path', 1.0 [feed mm/s], 30.0 [head mm/s]
         * - outer perimeter    'Perimeter Path', 1.0 [feed mm/s], 30.0 [head mm/s]
         * - solid layer        'Solid Path', 1.0 [feed mm/s], 30.0 [head mm/s]
         * - infill             'Sparse Infill Path', 1.7 [feed mm/s], 50.0 [head mm/s]
         *                      'Stacked Sparse Infill Path', 1.7 [feed mm/s], 50.0 [head mm/s]
         * - gap fill           'Crown Path', 0.5 [feed mm/s], 30.0 [head mm/s]
         *
         * Slic3r feature comments
         * - start sequence     N/A
         * - end sequence       N/A
         * - skirt              skirt
         * - raft               support material
         * - brim               brim
         * - support            support material
         * - inner perimeter    perimeter
         * - outer perimeter    perimeter
         * - solid layer        infill
         * - infill             infill
         * - gap fill           N/A
         */
        let feature = instruction.comment.trim().toLowerCase();
        let sourceMap = /\(line \d+\)/g.exec(feature);
        if (sourceMap) {
            feature = feature.slice(0, -(sourceMap[0].length)).trim();
        }
        if (feature) {
            if (feature === "layer end"
                || feature.includes("g-code postfix")) {
                if (currentState.value === enums_1.PrintStates.EndSequence) {
                    return currentState;
                }
                return new PrintState({
                    value: enums_1.PrintStates.EndSequence
                });
            }
            if (feature === "skirt"
                || feature === "type:skirt"
                || feature.startsWith("'prime pillar path'")) {
                if (currentState.value === enums_1.PrintStates.Skirt) {
                    return currentState;
                }
                return new PrintState({
                    value: enums_1.PrintStates.Skirt
                });
            }
            if (feature === "raft"
                || feature.startsWith("'raft path'")
                || feature.startsWith("'pillar path'")) {
                if (currentState.value === enums_1.PrintStates.Raft) {
                    return currentState;
                }
                return new PrintState({
                    value: enums_1.PrintStates.Raft
                });
            }
            if (feature === "brim") {
                if (currentState.value === enums_1.PrintStates.Brim) {
                    return currentState;
                }
                return new PrintState({
                    value: enums_1.PrintStates.Brim
                });
            }
            if (feature === "support"
                || (feature === "type:support" && currentState.value !== enums_1.PrintStates.Raft)) {
                if (currentState.value === enums_1.PrintStates.Support) {
                    return currentState;
                }
                return new PrintState({
                    value: enums_1.PrintStates.Support
                });
            }
            if (feature === "inner perimeter"
                || feature === "type:wall-inner"
                || feature.startsWith("'loop path'")) {
                if (currentState.value === enums_1.PrintStates.InnerPerimeter) {
                    return currentState;
                }
                return new PrintState({
                    value: enums_1.PrintStates.InnerPerimeter
                });
            }
            if (feature === "outer perimeter"
                || feature === "type:wall-outer"
                || feature.startsWith("'perimeter path'")) {
                if (currentState.value === enums_1.PrintStates.OuterPerimeter) {
                    return currentState;
                }
                return new PrintState({
                    value: enums_1.PrintStates.OuterPerimeter
                });
            }
            if (feature === "solid layer"
                || feature === "type:skin"
                || feature.startsWith("'solid path'")) {
                if (currentState.value === enums_1.PrintStates.SolidLayer) {
                    return currentState;
                }
                return new PrintState({
                    value: enums_1.PrintStates.SolidLayer
                });
            }
            if (feature === "infill"
                || feature === "type:fill"
                || feature.startsWith("'sparse infill path'")
                || feature.startsWith("'stacked sparse infill path'")) {
                if (currentState.value === enums_1.PrintStates.Infill) {
                    return currentState;
                }
                return new PrintState({
                    value: enums_1.PrintStates.Infill
                });
            }
            if (feature === "gap fill"
                || feature.startsWith("'crown path'")) {
                if (currentState.value === enums_1.PrintStates.GapFill) {
                    return currentState;
                }
                return new PrintState({
                    value: enums_1.PrintStates.GapFill
                });
            }
        }
        return currentState;
    }
}
exports.default = PrintStateMachine;
//# sourceMappingURL=print.js.map