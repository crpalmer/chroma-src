/**
 * @module RaftStateMachine
 */ /** */

import {isNullOrUndefined} from "util";
import IntegerStateMachine, {IntegerState, IntegerStateParams} from "./integer";
import InvalidStateParamsError from "../errors/invalid-state-params";
import {PrintStates} from "../enums";
import RaftInstruction from "../instructions/base";

export interface PrintStateParams extends IntegerStateParams {
    value: PrintStates
}

export class PrintState extends IntegerState {

    public readonly value: PrintStates;

    public constructor (params: PrintStateParams) {
        if (isNullOrUndefined(params.value) || !(params.value in PrintStates)) {
            throw new InvalidStateParamsError("Invalid value parameter '" + params.value + "' supplied to PrintState");
        }
        super(params);
    }

    public clone(): PrintState {
        return new PrintState({
            value: this.value
        });
    }

    public toString(): string {
        return "PrintState";
    }

}

export default class PrintStateMachine extends IntegerStateMachine {

    protected initialState: PrintState;

    public constructor (initialState: PrintState) {
        super(initialState);
    }

    public insertState(state: PrintState): void {
        super.insertState(state);
    }

    public clone(): PrintStateMachine {
        let copy = new PrintStateMachine(this.current);
        this.deepCopyStatesTo(copy);
        return copy;
    }

    public toString(): string {
        return "PrintStateMachine";
    }

    public static getNextState(currentState: PrintState, instruction: RaftInstruction): PrintState {

        /*
         * Simplify3D feature comments
         * - start sequence     N/A
         * - end sequence       layer end
         * - skirt              skirt
         * - raft               raft
         * - brim               brim
         * - support            support
         * - inner perimeter    inner perimeter
         * - outer perimeter    outer perimeter
         * - solid layer        solid layer
         * - infill             infill
         * - gap fill           gap fill
         *
         * Cura feature comments
         * - start sequence     N/A
         * - end sequence       N/A
         * - skirt              TYPE:SKIRT
         * - raft               RAFT
         *                      TYPE:SUPPORT
         * - brim               N/A
         * - support            TYPE:SUPPORT
         * - inner perimeter    TYPE:WALL-INNER
         * - outer perimeter    TYPE:WALL-OUTER
         * - solid layer        TYPE:SKIN
         * - infill             TYPE:FILL
         * - gap fill           N/A
         *
         * KISSlicer feature comments
         * - start sequence     *** G-code Prefix ***
         * - end sequence       *** G-code Postfix ***
         * - skirt              'Prime Pillar Path', 1.5 [feed mm/s], 30.0 [head mm/s]
         * - raft               'Raft Path', 1.6 [feed mm/s], 30.0 [head mm/s]
         *                      'Pillar Path', 6.3 [feed mm/s], 10.0 [head mm/s]
         * - brim               N/A
         * - support            'Support Path', 1.4 [feed mm/s], 50.0 [head mm/s]
         *                      'Support Interface Path', 1.4 [feed mm/s], 50.0 [head mm/s]
         * - inner perimeter    'Loop Path', 1.0 [feed mm/s], 30.0 [head mm/s]
         * - outer perimeter    'Perimeter Path', 1.0 [feed mm/s], 30.0 [head mm/s]
         * - solid layer        'Solid Path', 1.0 [feed mm/s], 30.0 [head mm/s]
         * - infill             'Sparse Infill Path', 1.7 [feed mm/s], 50.0 [head mm/s]
         *                      'Stacked Sparse Infill Path', 1.7 [feed mm/s], 50.0 [head mm/s]
         * - gap fill           'Crown Path', 0.5 [feed mm/s], 30.0 [head mm/s]
         *
         * Slic3r feature comments
         * - start sequence     N/A
         * - end sequence       N/A
         * - skirt              skirt
         * - raft               support material
         * - brim               brim
         * - support            support material
         * - inner perimeter    perimeter
         * - outer perimeter    perimeter
         * - solid layer        infill
         * - infill             infill
         * - gap fill           N/A
         */

        let feature = instruction.comment.trim().toLowerCase();
        let sourceMap = /\(line \d+\)/g.exec(feature);
        if (sourceMap) {
            feature = feature.slice(0, -(sourceMap[0].length)).trim();
        }

        if (feature) {
            if (feature === "layer end"
                || feature.includes("g-code postfix")) {
                if (currentState.value === PrintStates.EndSequence) {
                    return currentState;
                }
                return new PrintState({
                    value: PrintStates.EndSequence
                });
            }
            if (feature === "skirt"
                || feature === "type:skirt"
                || feature.startsWith("'prime pillar path'")) {
                if (currentState.value === PrintStates.Skirt) {
                    return currentState;
                }
                return new PrintState({
                    value: PrintStates.Skirt
                });
            }
            if (feature === "raft"
                || feature.startsWith("'raft path'")
                || feature.startsWith("'pillar path'")) {
                if (currentState.value === PrintStates.Raft) {
                    return currentState;
                }
                return new PrintState({
                    value: PrintStates.Raft
                });
            }
            if (feature === "brim") {
                if (currentState.value === PrintStates.Brim) {
                    return currentState;
                }
                return new PrintState({
                    value: PrintStates.Brim
                });
            }
            if (feature === "support"
                || (feature === "type:support" && currentState.value !== PrintStates.Raft)) {
                if (currentState.value === PrintStates.Support) {
                    return currentState;
                }
                return new PrintState({
                    value: PrintStates.Support
                });
            }
            if (feature === "inner perimeter"
                || feature === "type:wall-inner"
                || feature.startsWith("'loop path'")) {
                if (currentState.value === PrintStates.InnerPerimeter) {
                    return currentState;
                }
                return new PrintState({
                    value: PrintStates.InnerPerimeter
                });
            }
            if (feature === "outer perimeter"
                || feature === "type:wall-outer"
                || feature.startsWith("'perimeter path'")) {
                if (currentState.value === PrintStates.OuterPerimeter) {
                    return currentState;
                }
                return new PrintState({
                    value: PrintStates.OuterPerimeter
                });
            }
            if (feature === "solid layer"
                || feature === "type:skin"
                || feature.startsWith("'solid path'")) {
                if (currentState.value === PrintStates.SolidLayer) {
                    return currentState;
                }
                return new PrintState({
                    value: PrintStates.SolidLayer
                });
            }
            if (feature === "infill"
                || feature === "type:fill"
                || feature.startsWith("'sparse infill path'")
                || feature.startsWith("'stacked sparse infill path'")) {
                if (currentState.value === PrintStates.Infill) {
                    return currentState;
                }
                return new PrintState({
                    value: PrintStates.Infill
                });
            }
            if (feature === "gap fill"
                || feature.startsWith("'crown path'")) {
                if (currentState.value === PrintStates.GapFill) {
                    return currentState;
                }
                return new PrintState({
                    value: PrintStates.GapFill
                });
            }
        }

        return currentState;

    }

}
