/**
 * @module Raft
 * @preferred
 */ /** */

import RaftInstruction from "./instructions/base";
import RaftParser from "./parsers/base";
import RaftEngine from "./engines/base";
import {RaftState} from "./state-machines/base";
import InvalidArgumentError from "./errors/invalid-argument";
import BadMethodCallError from "./errors/bad-method-call";

export type playCallback = (currentInstruction: RaftInstruction,
                            currentState: Map<string, RaftState>,
                            programCounter?: number) => void;

export class RaftWrapper {

    private instructions: RaftInstruction[];
    private programCounter: number;
    private parser: RaftParser;

    public constructor(parser: RaftParser) {
        if (!(parser instanceof RaftParser)) {
            throw new InvalidArgumentError("Invalid RaftParser instance provided");
        }
        this.instructions = [];
        this.programCounter = 0;
        this.parser = parser;
    }

    public clone(): RaftWrapper {
        let copy = new RaftWrapper(this.parser.clone());
        copy.instructions = this.instructions.slice();
        copy.programCounter = this.programCounter;
        return copy;
    }

    public getCurrentInstruction(): RaftInstruction {
        if (this.instructions.length === 0) {
            throw new BadMethodCallError("No instructions have been loaded.");
        }
        if (this.programCounter === 0) {
            throw new BadMethodCallError("No instructions have yet been executed.");
        }
        if (this.programCounter > this.instructions.length) {
            throw new BadMethodCallError("Program counter is already at end of instruction list.");
        }
        return this.instructions[this.programCounter - 1];
    }

    public getParser(): RaftParser {
        return this.parser;
    }

    public getEngine(): RaftEngine {
        return this.parser.getEngine();
    }

    public getCurrentState(): Map<string, RaftState> {
        return this.getEngine().getCurrentState();
    }

    public open(inpath: string): void {
        let contents = this.parser.readFile(inpath);
        this.instructions = this.parser.parse(contents);
    }

    public save(outpath: string): void {
        let contents = this.parser.toOutput(this.instructions);
        this.parser.writeFile(outpath, contents);
    }

    public stepForward(): boolean {
        if (this.programCounter === this.instructions.length) {
            return false;
        }
        this.programCounter++;
        if (this.getEngine().needsExecuteForNextInstruction()) {
            this.getEngine().executeNext(this.getCurrentInstruction());
        } else {
            this.getEngine().stepForward();
        }
        return true;
    }

    public stepBackward(): boolean {
        if (this.programCounter === 0) {
            return false;
        }
        this.programCounter--;
        this.getEngine().stepBackward();
        return true;
    }

    public async play(iteratorCallback?: playCallback): Promise<boolean> {
        let _this = this;
        return new Promise<boolean>(async function (resolve, reject) {
            if (iteratorCallback !== undefined && (typeof iteratorCallback !== "function")) {
                reject();
                throw new InvalidArgumentError("Invalid callback function provided");
            }
            let useCB = (iteratorCallback !== undefined);
            while (_this.programCounter < _this.instructions.length) {
                _this.stepForward();
                if (useCB) {
                    try {
                        await iteratorCallback(_this.getCurrentInstruction(), _this.getCurrentState(), _this.programCounter);
                    } catch (e) {
                        reject(e);
                        return;
                    }
                }
            }
            resolve();
        });
    }

    public rewind(): void {
        while (this.programCounter > 0) {
            this.stepBackward();
        }
    }

    public insertInstruction(instruction: RaftInstruction): void {
        this.getEngine().invalidateFuture();
        this.instructions.splice(this.programCounter, 0, instruction);
        this.stepForward();
    }

    public deleteInstruction(): void {
        if (this.programCounter >= this.instructions.length) {
            throw new BadMethodCallError("Cannot delete; all instructions have been executed.");
        }
        this.getEngine().invalidateFuture();
        this.instructions.splice(this.programCounter, 1);
    }

}

export * from "./enums";
export * from "./engines";
export * from "./errors";
export * from "./instructions";
export * from "./parsers";
export * from "./state-machines";

