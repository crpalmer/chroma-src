/**
 * @module RaftEngine
 */ /** */

import RaftEngine, {RaftEngineOptions} from "./base";
import InvalidInstructionError from "../errors/invalid-instruction";
import {GCodeLine} from "../parsers/gcode";
import {CoordinateModes, DistanceUnits, PrintStates} from "../enums";
import RaftInstruction from "../instructions/base";
import LinearMoveInstruction from "../instructions/linear-move";
import ArcMoveInstruction from "../instructions/arc-move";
import DwellInstruction from "../instructions/dwell";
import EmptyInstruction from "../instructions/empty";
import GetPositionInstruction from "../instructions/get-position";
import SetCoordinateModeInstruction from "../instructions/set-coordinate-mode";
import SetPositionInstruction from "../instructions/set-position";
import HomeInstruction from "../instructions/home";
import ToolChangeInstruction from "../instructions/toolchange";
import SetToolheadTemperatureInstruction from "../instructions/set-toolhead-temperature";
import SetFanInstruction from "../instructions/set-fan";
import SetBedTemperatureInstruction from "../instructions/set-bed-temperature";
import StopIdleHoldInstruction from "../instructions/stop-idle-hold";
import DisableStepperMotorInstruction from "../instructions/disable-stepper-motor";
import SetUnitsInstruction from "../instructions/set-units";
import SleepInstruction from "../instructions/sleep";
import StopInstruction from "../instructions/stop";
import EmergencyStopInstruction from "../instructions/emergency-stop";
import FinishBufferInstruction from "../instructions/finish-buffer";
import DisplayMessageInstruction from "../instructions/display-message";
import RetractInstruction from "../instructions/retract";
import SetToolOffsetInstruction from "../instructions/set-tool-offset";
import BedStandbyInstruction from "../instructions/bed-standby";
import StabilizeToolheadTemperatureInstruction from "../instructions/stabilize-toolhead-temperature";
import StabilizeTemperatureInstruction from "../instructions/stabilize-temperature";
import StabilizeAllTemperaturesInstruction from "../instructions/stabilize-all-temperatures";
import SetPIDSampleIntervalInstruction from "../instructions/set-pid-sample-interval";
import SetMaxPrintAccelerationInstruction from "../instructions/set-max-print-acceleration";
import SetMaxJerkSpeedInstruction from "../instructions/set-max-jerk-speed";
import OffsetAxisInstruction from "../instructions/offset-axis";
import SetRetractLengthInstruction from "../instructions/set-retract-length";
import SetSpeedOverrideInstruction from "../instructions/set-speed-override";
import SetExtrusionOverrideInstruction from "../instructions/set-extrusion-override";
import PauseInstruction from "../instructions/pause";
import PlayBeepInstruction from "../instructions/play-beep";
import SetAxisTravelBoundInstruction from "../instructions/set-axis-travel-bound";
import LimitAxisTravelInstruction from "../instructions/limit-axis-travel";
import ExtrusionAxisStateMachine, {ExtrusionAxisState} from "../state-machines/extrusion-axis";
import PrintStateMachine, {PrintState} from "../state-machines/print";
import NonNegativeAxisStateMachine, {NonNegativeAxisState} from "../state-machines/non-negative-axis";
import IntegerStateMachine, {IntegerState} from "../state-machines/integer";
import StartSDPrintInstruction from "../instructions/start-sd-print";
import PauseSDPrintInstruction from "../instructions/pause-sd-print";
import {isNullOrUndefined} from "util";
import OffsetAxisStateMachine, {OffsetAxisState} from "../state-machines/offset-axis";
import {StandbyAxisState, default as StandbyAxisStateMachine} from "../state-machines/standby-axis";
import UnknownInstruction from "../instructions/unknown";
import MoveInstruction from "../instructions/move";
import OStartMulticolorInstruction from "../instructions/o-start-multicolor";
import OSoftResetInstruction from "../instructions/o-soft-reset";
import OSpliceDataInstruction from "../instructions/o-splice-data";
import {floatToHexString, intToHexString, int16ToHexString} from "../common/hex";
import OSpliceCountInstruction from "../instructions/o-splice-count";
import OPingDataInstruction from "../instructions/o-ping-data";
import SetMaxFeedrateInstruction from "../instructions/set-max-feedrate";
import OAlgorithmCountInstruction from "../instructions/o-algorithm-count";
import ZProbeInstruction from "../instructions/z-probe";
import OVersionInstruction from "../instructions/o-version";
import OPrinterProfileInstruction from "../instructions/o-printer-profile";
import OSlicerProfileInstruction from "../instructions/o-slicer-profile";
import OAdjustedPPMInstruction from "../instructions/o-adjusted-ppm";
import OMaterialsUsedInstruction from "../instructions/o-materials-used";
import OPingCountInstruction from "../instructions/o-ping-count";
import OHotSwapCountInstruction from "../instructions/o-hot-swap-count";
import OAlgorithmDataInstruction from "../instructions/o-algorithm-data";
import OHotSwapDataInstruction from "../instructions/o-hot-swap-data";

export interface RepRapEngineOptions extends RaftEngineOptions {
    // general/non-changing parameters
    defaultHomeDirectionMax?: boolean
    volumetricExtrusion: boolean
    filamentDiameter: number

    // initial X/Y/Z state parameters
    initialXYZCoordinateMode: CoordinateModes.Absolute | CoordinateModes.Relative

    // initial extrusion state parameters
    initialExtrusionCoordinateMode: CoordinateModes.Absolute | CoordinateModes.Relative
    retractDistance?: number
    unretractExtraLength?: number

    // initial fan state parameters
    initialFanSpeed?: number
    useToggleForFanControl?: boolean

    // initial toolhead state parameters
    initialToolheadIndex?: number
    toolheadCount: number
    independentExtruders?: boolean

    // initial print feature state parameters
    initialPrintState?: PrintStates
}

export default class RepRapEngine extends RaftEngine {

    public readonly toolheadCount: number;
    public readonly independentExtruders: boolean;
    public readonly volumetricExtrusion: boolean;
    public readonly defaultHomeDirectionMax: boolean;
    public readonly filamentDiameter: number;

    public constructor(options: RepRapEngineOptions) {
        super(options);

        this.toolheadCount = options.toolheadCount;
        this.independentExtruders = options.independentExtruders || false;
        this.volumetricExtrusion = options.volumetricExtrusion;
        this.defaultHomeDirectionMax = options.defaultHomeDirectionMax || false;
        this.filamentDiameter = options.filamentDiameter;

        if (this.independentExtruders) {
            for (let i = 0; i < this.toolheadCount; i++) {
                this.stateMachines["xTool" + i] = new OffsetAxisStateMachine(new OffsetAxisState({
                    coordinateMode: options.initialXYZCoordinateMode,
                    position: null,
                    offset: 0
                }));
                this.stateMachines["yTool" + i] = new OffsetAxisStateMachine(new OffsetAxisState({
                    coordinateMode: options.initialXYZCoordinateMode,
                    position: null,
                    offset: 0
                }));
                this.stateMachines["zTool" + i] = new OffsetAxisStateMachine(new OffsetAxisState({
                    coordinateMode: options.initialXYZCoordinateMode,
                    position: null,
                    offset: 0
                }));
            }
        } else {
            this.stateMachines["x"] = new OffsetAxisStateMachine(new OffsetAxisState({
                coordinateMode: options.initialXYZCoordinateMode,
                position: null,
                offset: 0
            }));
            this.stateMachines["y"] = new OffsetAxisStateMachine(new OffsetAxisState({
                coordinateMode: options.initialXYZCoordinateMode,
                position: null,
                offset: 0
            }));
            this.stateMachines["z"] = new OffsetAxisStateMachine(new OffsetAxisState({
                coordinateMode: options.initialXYZCoordinateMode,
                position: null,
                offset: 0
            }));
        }
        this.stateMachines["extrusion"] = new ExtrusionAxisStateMachine(new ExtrusionAxisState({
            coordinateMode: options.initialExtrusionCoordinateMode,
            position: null,
            totalDispensed: 0,
            retraction: 0,
            retractDistance: null,
            unretractExtraLength: null
        }));
        this.stateMachines["feedrate"] = new NonNegativeAxisStateMachine(new NonNegativeAxisState({
            position: null
        }));
        this.stateMachines["extruderTemp"] = new StandbyAxisStateMachine(new StandbyAxisState({
            position: null,
            standby: true
        }));
        this.stateMachines["bedTemp"] = new StandbyAxisStateMachine(new StandbyAxisState({
            position: null,
            standby: true
        }));
        this.stateMachines["fan"] = new NonNegativeAxisStateMachine(new NonNegativeAxisState({
            position: isNullOrUndefined(options.initialFanSpeed) ? null : options.initialFanSpeed
        }));
        this.stateMachines["toolhead"] = new IntegerStateMachine(new IntegerState({
            value: isNullOrUndefined(options.initialToolheadIndex) ? null : options.initialToolheadIndex
        }));
        this.stateMachines["printState"] = new PrintStateMachine(new PrintState({
            value: isNullOrUndefined(options.initialPrintState) ? PrintStates.None : options.initialPrintState
        }));
    }

    public clone(): RepRapEngine {
        let copy = new RepRapEngine({
            toolheadCount: this.toolheadCount,
            independentExtruders: this.independentExtruders,
            volumetricExtrusion: this.volumetricExtrusion,
            defaultHomeDirectionMax: this.defaultHomeDirectionMax,
            filamentDiameter: this.filamentDiameter,
            initialXYZCoordinateMode: this.stateMachines["x"].getCurrentState().coordinateMode,
            initialExtrusionCoordinateMode: this.stateMachines["extrusion"].getCurrentState().coordinateMode
        });
        this.copyStateMachinesTo(copy);
        return copy;
    }

    public toRaftInstruction(line: GCodeLine): RaftInstruction {

        if (!line.command) {
            return new EmptyInstruction({
                comment: line.comment
            });
        }

        if (line.command === "G0" || line.command === "G1") return fromG0G1(line);
        if (line.command === "G2" || line.command === "G3") return fromG2G3(line);
        if (line.command === "G4") return fromG4(line);
        if (line.command === "G10" || line.command === "G11") return fromG10G11(line);
        if (line.command === "G20" || line.command === "G21") return fromG20G21(line);
        if (line.command === "G28") return fromG28(line);
        if (line.command === "G29") return fromG29(line);
        if (line.command === "G90") return fromG90(line);
        if (line.command === "G91") return fromG91(line);
        if (line.command === "G92") return fromG92(line);

        if (line.command === "M0") return fromM0(line);
        if (line.command === "M1") return fromM1(line);
        if (line.command === "M18") return fromM18(line);
        if (line.command === "M24") return fromM24(line);
        if (line.command === "M25") return fromM25(line);
        if (line.command === "M82") return fromM82(line);
        if (line.command === "M83") return fromM83(line);
        if (line.command === "M84") return fromM84(line);
        if (line.command === "M104") return fromM104(line);
        if (line.command === "M106") return fromM106(line);
        if (line.command === "M107") return fromM107(line);
        if (line.command === "M109") return fromM109(line);
        if (line.command === "M112") return fromM112(line);
        if (line.command === "M114") return fromM114(line);
        if (line.command === "M116") return fromM116(line);
        if (line.command === "M117") return fromM117(line);
        if (line.command === "M135") return fromM135(line);
        if (line.command === "M140") return fromM140(line);
        if (line.command === "M144") return fromM144(line);
        if (line.command === "M190") return fromM190(line);
        if (line.command === "M201") return fromM201(line);
        if (line.command === "M203") return fromM203(line);
        if (line.command === "M206") return fromM206(line);
        if (line.command === "M207") return fromM207(line);
        if (line.command === "M208") return fromM208(line);
        if (line.command === "M220") return fromM220(line);
        if (line.command === "M221") return fromM221(line);
        if (line.command === "M226") return fromM226(line);
        if (line.command === "M300") return fromM300(line);
        if (line.command === "M400") return fromM400(line);
        if (line.command === "M564") return fromM564(line);
        if (line.command === "M566") return fromM566(line);

        if (line.command[0].toUpperCase() === "T") return fromT(line);

        return super.toRaftInstruction(line);
    }

    public toOutputInstruction(instruction: RaftInstruction): GCodeLine {

        if (instruction instanceof EmptyInstruction) {
            return {
                command: null,
                comment: instruction.comment
            };
        }
        if (instruction instanceof UnknownInstruction) {
            return {
                command: null,
                original: instruction.original,
                comment: instruction.comment
            };
        }

        if (instruction instanceof LinearMoveInstruction) return fromLinearMove(instruction);
        if (instruction instanceof ArcMoveInstruction) return fromArcMove(instruction);
        if (instruction instanceof DwellInstruction) return fromDwell(instruction);
        if (instruction instanceof SetToolOffsetInstruction) return fromSetToolOffset(instruction);
        if (instruction instanceof RetractInstruction) return fromRetract(instruction);
        if (instruction instanceof SetUnitsInstruction) return fromSetUnits(instruction);
        if (instruction instanceof HomeInstruction) return fromHome(instruction);
        if (instruction instanceof ZProbeInstruction) return <GCodeLine> fromZProbe(instruction);
        if (instruction instanceof SetCoordinateModeInstruction) return fromSetCoordinateMode(instruction);
        if (instruction instanceof SetPositionInstruction) return fromSetPosition(instruction);

        if (instruction instanceof StopInstruction) return fromStop(instruction);
        if (instruction instanceof SleepInstruction) return fromSleep(instruction);
        if (instruction instanceof DisableStepperMotorInstruction) return fromDisableStepperMotor(instruction);
        if (instruction instanceof StartSDPrintInstruction) return fromStartSDPrint(instruction);
        if (instruction instanceof PauseSDPrintInstruction) return fromPauseSDPrint(instruction);
        if (instruction instanceof StopIdleHoldInstruction) return fromStopIdleHold(instruction);
        if (instruction instanceof SetToolheadTemperatureInstruction) return fromSetToolheadTemperature(instruction);
        if (instruction instanceof SetFanInstruction) return fromSetFan(instruction);
        if (instruction instanceof EmergencyStopInstruction) return fromEmergencyStop(instruction);
        if (instruction instanceof GetPositionInstruction) return fromGetPosition(instruction);
        if (instruction instanceof StabilizeTemperatureInstruction) return fromStabilizeTemperature(instruction);
        if (instruction instanceof DisplayMessageInstruction) return fromDisplayMessage(instruction);
        if (instruction instanceof SetPIDSampleIntervalInstruction) return fromSetPIDSampleInterval(instruction);
        if (instruction instanceof BedStandbyInstruction) return fromBedStandby(instruction);
        if (instruction instanceof SetBedTemperatureInstruction) return fromSetBedTemperature(instruction);
        if (instruction instanceof SetMaxPrintAccelerationInstruction) return fromSetMaxPrintAcceleration(instruction);
        if (instruction instanceof SetMaxFeedrateInstruction) return fromSetMaxFeedrate(instruction);
        if (instruction instanceof OffsetAxisInstruction) return fromOffsetAxis(instruction);
        if (instruction instanceof SetRetractLengthInstruction) return fromSetRetractLength(instruction);
        if (instruction instanceof SetAxisTravelBoundInstruction) return fromSetAxisTravelBound(instruction);
        if (instruction instanceof SetSpeedOverrideInstruction) return fromSetSpeedOverride(instruction);
        if (instruction instanceof SetExtrusionOverrideInstruction) return fromSetExtrusionOverride(instruction);
        if (instruction instanceof PauseInstruction) return fromPause(instruction);
        if (instruction instanceof PlayBeepInstruction) return fromPlayBeep(instruction);
        if (instruction instanceof FinishBufferInstruction) return fromFinishBuffer(instruction);
        if (instruction instanceof LimitAxisTravelInstruction) return fromLimitAxisTravel(instruction);
        if (instruction instanceof SetMaxJerkSpeedInstruction) return fromSetMaxJerkSpeed(instruction);

        if (instruction instanceof ToolChangeInstruction) return fromToolChange(instruction);

        if (instruction instanceof OStartMulticolorInstruction) return fromOStartMulticolor(instruction);
        if (instruction instanceof OSoftResetInstruction) return fromOSoftReset(instruction);
        if (instruction instanceof OVersionInstruction) return fromOVersion(instruction);
        if (instruction instanceof OPrinterProfileInstruction) return fromOPrinterProfile(instruction);
        if (instruction instanceof OSlicerProfileInstruction) return fromOSlicerProfile(instruction);
        if (instruction instanceof OAdjustedPPMInstruction) return fromOAdjustedPPM(instruction);
        if (instruction instanceof OMaterialsUsedInstruction) return fromOMaterialsUsed(instruction);
        if (instruction instanceof OSpliceCountInstruction) return fromOSpliceCount(instruction);
        if (instruction instanceof OPingCountInstruction) return fromOPingCount(instruction);
        if (instruction instanceof OAlgorithmCountInstruction) return fromOAlgorithmCount(instruction);
        if (instruction instanceof OHotSwapCountInstruction) return fromOHotSwapCount(instruction);
        if (instruction instanceof OSpliceDataInstruction) return fromOSpliceData(instruction);
        if (instruction instanceof OPingDataInstruction) return fromOPingData(instruction);
        if (instruction instanceof OAlgorithmDataInstruction) return fromOAlgorithmData(instruction);
        if (instruction instanceof OHotSwapDataInstruction) return fromOHotSwapData(instruction);

        return <GCodeLine> super.toOutputInstruction(instruction);

    }

    public executeNext(instruction: RaftInstruction): void {

        if (instruction instanceof LinearMoveInstruction || instruction instanceof ArcMoveInstruction) {

            let xKey, yKey, zKey;
            if (this.independentExtruders) {
                let currentToolhead = this.stateMachines["toolhead"].getCurrentState().value;
                xKey = "xTool" + currentToolhead;
                yKey = "yTool" + currentToolhead;
                zKey = "zTool" + currentToolhead;
            } else {
                xKey = "x";
                yKey = "y";
                zKey = "z";
            }

            if (!this.stateMachines["x"].stateInserted && instruction.x !== null) {
                let currentXState: OffsetAxisState = this.stateMachines[xKey].getCurrentState();
                let newXPosition = currentXState.position || 0;
                if (((instruction instanceof LinearMoveInstruction) && instruction.relativeX)
                    || currentXState.coordinateMode === CoordinateModes.Relative) {
                    newXPosition += instruction.x;
                } else {
                    newXPosition = instruction.x;
                }
                this.stateMachines[xKey].insertState(new OffsetAxisState({
                    coordinateMode: currentXState.coordinateMode,
                    offset: currentXState.offset,
                    position: newXPosition
                }));
                this.stateMachines[xKey].stateInserted = true;
            }

            if (!this.stateMachines["y"].stateInserted && instruction.y !== null) {
                let currentYState: OffsetAxisState = this.stateMachines[yKey].getCurrentState();
                let newYPosition = currentYState.position || 0;
                if (((instruction instanceof LinearMoveInstruction) && instruction.relativeY)
                    || currentYState.coordinateMode === CoordinateModes.Relative) {
                    newYPosition += instruction.y;
                } else {
                    newYPosition = instruction.y;
                }
                this.stateMachines[yKey].insertState(new OffsetAxisState({
                    coordinateMode: currentYState.coordinateMode,
                    offset: currentYState.offset,
                    position: newYPosition
                }));
                this.stateMachines[yKey].stateInserted = true;
            }

            if (!this.stateMachines["feedrate"].stateInserted && instruction.feedrate !== null) {
                this.stateMachines["feedrate"].insertState(new NonNegativeAxisState({
                    position: instruction.feedrate
                }));
                this.stateMachines["feedrate"].stateInserted = true;
            }

            if (!this.stateMachines["extrusion"].stateInserted && instruction.extrusion !== null) {
                let currentEState: ExtrusionAxisState = this.stateMachines["extrusion"].getCurrentState();
                let newEState = getNewExtrusionStateAfterMoveCommand(
                    instruction,
                    currentEState,
                    this.volumetricExtrusion,
                    this.filamentDiameter);
                this.stateMachines["extrusion"].insertState(newEState);
                this.stateMachines["extrusion"].stateInserted = true;
            }

            if (instruction instanceof LinearMoveInstruction) {

                if (!this.stateMachines["z"].stateInserted && instruction.z !== null) {
                    let currentZState: OffsetAxisState = this.stateMachines[zKey].getCurrentState();
                    let newZPosition = currentZState.position || 0;
                    if (instruction.relativeZ || currentZState.coordinateMode === CoordinateModes.Relative) {
                        newZPosition += instruction.z;
                    } else {
                        newZPosition = instruction.z;
                    }
                    this.stateMachines[zKey].insertState(new OffsetAxisState({
                        coordinateMode: currentZState.coordinateMode,
                        offset: currentZState.offset,
                        position: newZPosition
                    }));
                    this.stateMachines[zKey].stateInserted = true;
                }

            }

        }

        if (instruction instanceof RetractInstruction) {

            if (!this.stateMachines["extrusion"].stateInserted) {
                let currentEState: ExtrusionAxisState = this.stateMachines["extrusion"].getCurrentState();
                let newEPosition;
                let newRetraction;

                if (instruction.isUnretract) {
                    newEPosition = currentEState.position + (currentEState.retractDistance + currentEState.unretractExtraLength);
                    newRetraction = currentEState.retraction - (currentEState.retractDistance + currentEState.unretractExtraLength);
                } else {
                    newEPosition = currentEState.position - currentEState.retractDistance;
                    newRetraction = currentEState.retraction + currentEState.retractDistance;
                }

                this.stateMachines["extrusion"].insertState(new ExtrusionAxisState({
                    coordinateMode: currentEState.coordinateMode,
                    retractDistance: currentEState.retractDistance,
                    unretractExtraLength: currentEState.unretractExtraLength,
                    position: newEPosition,
                    totalDispensed: currentEState.totalDispensed,
                    retraction: newRetraction,
                }));
                this.stateMachines["extrusion"].stateInserted = true;
            }

        }

        if ((instruction instanceof SetToolOffsetInstruction) || (instruction instanceof OffsetAxisInstruction)) {

            let xKey, yKey, zKey;
            if (this.independentExtruders) {
                let currentToolhead = this.stateMachines["toolhead"].getCurrentState().value;
                xKey = "xTool" + (instruction instanceof SetToolOffsetInstruction ? instruction.toolhead : currentToolhead);
                yKey = "yTool" + (instruction instanceof SetToolOffsetInstruction ? instruction.toolhead : currentToolhead);
                zKey = "zTool" + (instruction instanceof SetToolOffsetInstruction ? instruction.toolhead : currentToolhead);
            } else {
                xKey = "x";
                yKey = "y";
                zKey = "z";
            }

            if (!this.stateMachines[xKey].stateInserted && instruction.x !== null) {
                let currentXState: OffsetAxisState = this.stateMachines["x"].getCurrentState();
                this.stateMachines[xKey].insertState(new OffsetAxisState({
                    coordinateMode: currentXState.coordinateMode,
                    offset: instruction.x,
                    position: currentXState.position - instruction.x
                }));
                this.stateMachines[xKey].stateInserted = true;
            }

            if (!this.stateMachines[yKey].stateInserted && instruction.y !== null) {
                let currentYState: OffsetAxisState = this.stateMachines["y"].getCurrentState();
                this.stateMachines[yKey].insertState(new OffsetAxisState({
                    coordinateMode: currentYState.coordinateMode,
                    offset: instruction.y,
                    position: currentYState.position - instruction.y
                }));
                this.stateMachines[yKey].stateInserted = true;
            }

            if (!this.stateMachines[zKey].stateInserted && instruction.z !== null) {
                let currentZState: OffsetAxisState = this.stateMachines["z"].getCurrentState();
                this.stateMachines[zKey].insertState(new OffsetAxisState({
                    coordinateMode: currentZState.coordinateMode,
                    offset: instruction.z,
                    position: currentZState.position - instruction.z
                }));
                this.stateMachines[zKey].stateInserted = true;
            }

        }

        if (instruction instanceof HomeInstruction) {

            if (!this.stateMachines["x"].stateInserted && instruction.x) {
                let currentXState: OffsetAxisState = this.stateMachines["x"].getCurrentState();
                this.stateMachines["x"].insertState(new OffsetAxisState({
                    coordinateMode: currentXState.coordinateMode,
                    offset: currentXState.offset,
                    position: null
                }));
                this.stateMachines["x"].stateInserted = true;
            }

            if (!this.stateMachines["y"].stateInserted && instruction.y) {
                let currentYState: OffsetAxisState = this.stateMachines["y"].getCurrentState();
                this.stateMachines["y"].insertState(new OffsetAxisState({
                    coordinateMode: currentYState.coordinateMode,
                    offset: currentYState.offset,
                    position: null
                }));
                this.stateMachines["y"].stateInserted = true;
            }

            if (!this.stateMachines["z"].stateInserted && instruction.z) {
                let currentZState: OffsetAxisState = this.stateMachines["z"].getCurrentState();
                this.stateMachines["z"].insertState(new OffsetAxisState({
                    coordinateMode: currentZState.coordinateMode,
                    offset: currentZState.offset,
                    position: null
                }));
                this.stateMachines["z"].stateInserted = true;
            }

        }

        if (instruction instanceof SetCoordinateModeInstruction) {

            if (instruction.xyz !== CoordinateModes.None) {

                if (this.independentExtruders) {
                    for (let i = 0; i < this.toolheadCount; i++) {
                        if (!this.stateMachines["xTool" + i].stateInserted
                            && !this.stateMachines["yTool" + i].stateInserted
                            && !this.stateMachines["zTool" + i].stateInserted) {

                            let currentXState: OffsetAxisState = this.stateMachines["xTool" + i].getCurrentState();
                            let currentYState: OffsetAxisState = this.stateMachines["yTool" + i].getCurrentState();
                            let currentZState: OffsetAxisState = this.stateMachines["zTool" + i].getCurrentState();
                            this.stateMachines["xTool" + i].insertState(new OffsetAxisState({
                                coordinateMode: instruction.xyz,
                                offset: currentXState.offset,
                                position: currentXState.position
                            }));
                            this.stateMachines["yTool" + i].insertState(new OffsetAxisState({
                                coordinateMode: instruction.xyz,
                                offset: currentYState.offset,
                                position: currentYState.position
                            }));
                            this.stateMachines["zTool" + i].insertState(new OffsetAxisState({
                                coordinateMode: instruction.xyz,
                                offset: currentZState.offset,
                                position: currentZState.position
                            }));
                            this.stateMachines["xTool" + i].stateInserted = true;
                            this.stateMachines["yTool" + i].stateInserted = true;
                            this.stateMachines["zTool" + i].stateInserted = true;
                        }
                    }
                } else {
                    if (!this.stateMachines["x"].stateInserted
                        && !this.stateMachines["y"].stateInserted
                        && !this.stateMachines["z"].stateInserted) {

                        let currentXState: OffsetAxisState = this.stateMachines["x"].getCurrentState();
                        let currentYState: OffsetAxisState = this.stateMachines["y"].getCurrentState();
                        let currentZState: OffsetAxisState = this.stateMachines["z"].getCurrentState();
                        this.stateMachines["x"].insertState(new OffsetAxisState({
                            coordinateMode: instruction.xyz,
                            offset: currentXState.offset,
                            position: currentXState.position
                        }));
                        this.stateMachines["y"].insertState(new OffsetAxisState({
                            coordinateMode: instruction.xyz,
                            offset: currentYState.offset,
                            position: currentYState.position
                        }));
                        this.stateMachines["z"].insertState(new OffsetAxisState({
                            coordinateMode: instruction.xyz,
                            offset: currentZState.offset,
                            position: currentZState.position
                        }));
                        this.stateMachines["x"].stateInserted = true;
                        this.stateMachines["y"].stateInserted = true;
                        this.stateMachines["z"].stateInserted = true;
                    }
                }

            }

            if (!this.stateMachines["extrusion"].stateInserted && instruction.extrusion !== CoordinateModes.None) {
                let currentEState: ExtrusionAxisState = this.stateMachines["extrusion"].getCurrentState();
                this.stateMachines["extrusion"].insertState(new ExtrusionAxisState({
                    coordinateMode: instruction.extrusion,
                    retractDistance: currentEState.retractDistance,
                    unretractExtraLength: currentEState.unretractExtraLength,
                    position: currentEState.position,
                    totalDispensed: currentEState.totalDispensed,
                    retraction: currentEState.retraction,
                }));
                this.stateMachines["extrusion"].stateInserted = true;
            }

        }

        if (instruction instanceof SetPositionInstruction) {

            let xKey, yKey, zKey;
            if (this.independentExtruders) {
                let currentToolhead = this.stateMachines["toolhead"].getCurrentState().value;
                xKey = "xTool" + currentToolhead;
                yKey = "yTool" + currentToolhead;
                zKey = "zTool" + currentToolhead;
            } else {
                xKey = "x";
                yKey = "y";
                zKey = "z";
            }

            if (!this.stateMachines[xKey].stateInserted && instruction.x !== null) {
                let currentXState: OffsetAxisState = this.stateMachines["x"].getCurrentState();
                this.stateMachines[xKey].insertState(new OffsetAxisState({
                    coordinateMode: currentXState.coordinateMode,
                    offset: currentXState.offset,
                    position: instruction.x
                }));
                this.stateMachines[xKey].stateInserted = true;
            }

            if (!this.stateMachines[yKey].stateInserted && instruction.y !== null) {
                let currentYState: OffsetAxisState = this.stateMachines["y"].getCurrentState();
                this.stateMachines[yKey].insertState(new OffsetAxisState({
                    coordinateMode: currentYState.coordinateMode,
                    offset: currentYState.offset,
                    position: instruction.y
                }));
                this.stateMachines[yKey].stateInserted = true;
            }

            if (!this.stateMachines[zKey].stateInserted && instruction.z !== null) {
                let currentZState: OffsetAxisState = this.stateMachines["z"].getCurrentState();
                this.stateMachines[zKey].insertState(new OffsetAxisState({
                    coordinateMode: currentZState.coordinateMode,
                    offset: currentZState.offset,
                    position: instruction.z
                }));
                this.stateMachines[zKey].stateInserted = true;
            }

            if (!this.stateMachines["extrusion"].stateInserted && instruction.extrusion !== null) {
                let currentEState: ExtrusionAxisState = this.stateMachines["extrusion"].getCurrentState();
                this.stateMachines["extrusion"].insertState(new ExtrusionAxisState({
                    coordinateMode: currentEState.coordinateMode,
                    retractDistance: currentEState.retractDistance,
                    unretractExtraLength: currentEState.unretractExtraLength,
                    position: instruction.extrusion,
                    totalDispensed: currentEState.totalDispensed,
                    retraction: currentEState.retraction,
                }));
                this.stateMachines["extrusion"].stateInserted = true;
            }

        }

        if (instruction instanceof SetToolheadTemperatureInstruction) {

            if (!this.stateMachines["extruderTemp"].stateInserted) {
                let currentTempState: StandbyAxisState = this.stateMachines["extruderTemp"].getCurrentState();
                this.stateMachines["extruderTemp"].insertState(new StandbyAxisState({
                    position: instruction.temperature,
                    standby: currentTempState.standby
                }));
                this.stateMachines["extruderTemp"].stateInserted = true;
            }

        }

        if (instruction instanceof SetFanInstruction) {

            if (!this.stateMachines["fan"].stateInserted) {
                this.stateMachines["fan"].insertState(new NonNegativeAxisState({
                    position: instruction.value
                }));
                this.stateMachines["fan"].stateInserted = true;
            }

        }

        if (instruction instanceof BedStandbyInstruction) {

            if (!this.stateMachines["bedTemp"].stateInserted) {
                let currentBedState: StandbyAxisState = this.stateMachines["bedTemp"].getCurrentState();
                this.stateMachines["bedTemp"].insertState(new StandbyAxisState({
                    position: currentBedState.position,
                    standby: instruction.exitStandby
                }));
                this.stateMachines["bedTemp"].stateInserted = true;
            }

        }

        if (instruction instanceof SetBedTemperatureInstruction) {

            if (!this.stateMachines["bedTemp"].stateInserted) {
                this.stateMachines["bedTemp"].insertState(new StandbyAxisState({
                    position: instruction.temperature,
                    standby: false
                }));
                this.stateMachines["bedTemp"].stateInserted = true;
            }

        }

        if (instruction instanceof SetRetractLengthInstruction) {

            if (!this.stateMachines["extrusion"].stateInserted) {
                let currentEState: ExtrusionAxisState = this.stateMachines["extrusion"].getCurrentState();
                this.stateMachines["extrusion"].insertState(new ExtrusionAxisState({
                    coordinateMode: currentEState.coordinateMode,
                    retractDistance: instruction.retractLength,
                    unretractExtraLength: instruction.unretractLengthOffset,
                    position: currentEState.position,
                    totalDispensed: currentEState.totalDispensed,
                    retraction: currentEState.position,
                }));
                this.stateMachines["extrusion"].stateInserted = true;
            }

        }

        if (instruction instanceof ToolChangeInstruction) {

            if (!this.stateMachines["toolhead"].stateInserted) {
                this.stateMachines["toolhead"].insertState(new IntegerState({
                    value: instruction.toolhead
                }));
                this.stateMachines["toolhead"].stateInserted = true;
            }

        }

        if (!this.stateMachines["printState"].stateInserted && instruction.comment) {

            let currentPrintState: PrintState = this.stateMachines["printState"].getCurrentState();
            let nextState = PrintStateMachine.getNextState(currentPrintState, instruction);
            this.stateMachines["printState"].insertState(nextState);
            this.stateMachines["printState"].stateInserted = true;

        }

        super.executeNext(instruction);

    }

    public toString(): string {
        return "RepRapEngine";
    }

}

export function getNewExtrusionStateAfterMoveCommand(
    instruction: MoveInstruction,
    currentState: ExtrusionAxisState,
    volumetric: boolean = false,
    filamentDiameter: number = 1.75): ExtrusionAxisState {

    let newEPosition = currentState.position || 0;
    let newTotalDispensed = currentState.totalDispensed;
    let newRetraction = currentState.retraction;

    if (currentState.coordinateMode === CoordinateModes.Relative) {
        if (instruction.extrusion < 0) {
            // relative, negative extrusion
            newEPosition += instruction.extrusion;
            newRetraction -= instruction.extrusion;
        } else if (instruction.extrusion > 0) {
            // relative, positive extrusion
            newEPosition += instruction.extrusion;
            newRetraction = Math.max(0, currentState.retraction - instruction.extrusion);
            if (newRetraction === 0) {
                if (volumetric) {
                    newTotalDispensed += 4 * (instruction.extrusion - currentState.retraction)
                        / (Math.PI * Math.pow(filamentDiameter, 2));
                } else {
                    newTotalDispensed += instruction.extrusion - currentState.retraction;
                }
            }
        }
    } else {
        let positionDelta = instruction.extrusion - currentState.position;
        if (instruction.extrusion < currentState.position) {
            // absolute, negative extrusion
            newEPosition = instruction.extrusion;
            newRetraction -= positionDelta;
        } else if (instruction.extrusion > currentState.position) {
            // absolute, positive extrusion
            newEPosition = instruction.extrusion;
            newRetraction = Math.max(0, currentState.retraction - positionDelta);
            if (newRetraction === 0) {
                if (volumetric) {
                    newTotalDispensed += 4 * (positionDelta - currentState.retraction)
                        / (Math.PI * Math.pow(filamentDiameter, 2));
                } else {
                    newTotalDispensed += positionDelta - currentState.retraction;
                }
            }
        }
    }

    return new ExtrusionAxisState({
        coordinateMode: currentState.coordinateMode,
        retractDistance: currentState.retractDistance,
        unretractExtraLength: currentState.unretractExtraLength,
        position: newEPosition,
        totalDispensed: newTotalDispensed,
        retraction: newRetraction,
    });

}

/**
 * GCode-to-RaftInstruction translation functions
 */

function fromG0G1(line: GCodeLine): LinearMoveInstruction {
    return new LinearMoveInstruction({
        x: line.x,
        y: line.y,
        z: line.z,
        extrusion: line.e,
        feedrate: line.f,
        isRapidMove: line.command === "G0",
        comment: line.comment
    });
}
function fromG2G3(line: GCodeLine): ArcMoveInstruction {
    return new ArcMoveInstruction({
        clockwise: line.command === "G2",
        x: line.x,
        y: line.y,
        i: line.i,
        j: line.j,
        extrusion: line.e,
        feedrate: line.f,
        comment: line.comment
    });
}
function fromG4(line: GCodeLine): DwellInstruction {
    if (line.p !== undefined) {
        return new DwellInstruction({
            duration: line.p,
            comment: line.comment
        });
    }
    if (line.s !== undefined) {
        return new DwellInstruction({
            duration: line.s,
            useMilliseconds: false,
            comment: line.comment
        });
    }
    throw new InvalidInstructionError("No duration parameter supplied for dwell instruction (e.g. G4 P2000 or G4 S2)");
}
function fromG10G11(line: GCodeLine): RetractInstruction | SetToolOffsetInstruction {
    if (line.command === "G10" && line.hasOwnProperty("p")) {
        return new SetToolOffsetInstruction({
            toolhead: line.p,
            x: line.x,
            y: line.y,
            z: line.z,
            comment: line.comment
        });
    }
    return new RetractInstruction({
        isUnretract: (line.command === "G11"),
        comment: line.comment
    });
}
function fromG20G21(line: GCodeLine): SetUnitsInstruction {
    return new SetUnitsInstruction({
        units: (line.command === "G20" ? DistanceUnits.Inches : DistanceUnits.Millimeters),
        comment: line.comment
    });
}
function fromG28(line: GCodeLine): HomeInstruction {
    if (line.x === undefined && line.y === undefined && line.z === undefined) {
        return new HomeInstruction({
            x: true,
            y: true,
            z: true,
            comment: line.comment
        });
    }
    return new HomeInstruction({
        x: (typeof line.x === "number") ? line.x : line.hasOwnProperty("x"),
        y: (typeof line.y === "number") ? line.y : line.hasOwnProperty("y"),
        z: (typeof line.z === "number") ? line.z : line.hasOwnProperty("z"),
        comment: line.comment
    });
}
function fromG29(line: GCodeLine): ZProbeInstruction {
    return new ZProbeInstruction({
        original: line.original
    });
}
function fromG90(line: GCodeLine): SetCoordinateModeInstruction {
    return new SetCoordinateModeInstruction({
        xyz: CoordinateModes.Absolute,
        comment: line.comment
    });
}
function fromG91(line: GCodeLine): SetCoordinateModeInstruction {
    return new SetCoordinateModeInstruction({
        xyz: CoordinateModes.Relative,
        comment: line.comment
    });
}
function fromG92(line: GCodeLine): SetPositionInstruction {
    if (line.x === undefined && line.y === undefined && line.z === undefined && line.e === undefined) {
        return new SetPositionInstruction({
            x: 0,
            y: 0,
            z: 0,
            extrusion: 0,
            comment: line.comment
        });
    }
    return new SetPositionInstruction({
        x: line.x,
        y: line.y,
        z: line.z,
        extrusion: line.e,
        comment: line.comment
    });
}

export function fromT(line: GCodeLine): ToolChangeInstruction {
    let tool: number = parseInt(line.command.substr(1));
    return new ToolChangeInstruction({
        toolhead: tool,
        comment: line.comment
    });
}

function fromM0(line: GCodeLine): StopInstruction {
    return new StopInstruction({
        keepHeatersActive: (line.hasOwnProperty("h") && !!line.h),
        comment: line.comment
    });
}
function fromM1(line: GCodeLine): SleepInstruction {
    return new SleepInstruction({
        comment: line.comment
    });
}
function fromM18(line: GCodeLine): DisableStepperMotorInstruction {
    if (line.x === undefined && line.y === undefined && line.z === undefined && line.e === undefined) {
        return new DisableStepperMotorInstruction({
            comment: line.comment
        });
    }
    return new DisableStepperMotorInstruction({
        x: line.hasOwnProperty("x"),
        y: line.hasOwnProperty("y"),
        z: line.hasOwnProperty("z"),
        e: line.hasOwnProperty("e"),
        comment: line.comment
    });
}
function fromM24(line: GCodeLine): StartSDPrintInstruction {
    return new StartSDPrintInstruction({
        comment: line.comment
    });
}
function fromM25(line: GCodeLine): PauseSDPrintInstruction {
    return new PauseSDPrintInstruction({
        comment: line.comment
    });
}
function fromM82(line: GCodeLine): SetCoordinateModeInstruction {
    return new SetCoordinateModeInstruction({
        extrusion: CoordinateModes.Absolute,
        comment: line.comment
    });
}
function fromM83(line: GCodeLine): SetCoordinateModeInstruction {
    return new SetCoordinateModeInstruction({
        extrusion: CoordinateModes.Relative,
        comment: line.comment
    });
}
function fromM84(line: GCodeLine): StopIdleHoldInstruction {
    return new StopIdleHoldInstruction({
        timeout: line.s,
        comment: line.comment
    });
}
function fromM104(line: GCodeLine): SetToolheadTemperatureInstruction {
    return new SetToolheadTemperatureInstruction({
        toolhead: line.t,
        temperature: (line.s === undefined ? null : line.s),
        stabilize: false,
        comment: line.comment
    });
}
function fromM106(line: GCodeLine): SetFanInstruction {
    if (line.s === undefined) {
        throw new InvalidInstructionError("No fan speed parameter supplied for set fan instruction (e.g. M106 S255)");
    }
    return new SetFanInstruction({
        isToggle: false,
        fanNumber: line.p,
        value: line.s,
        comment: line.comment
    });
}
function fromM107(line: GCodeLine): SetFanInstruction {
    return new SetFanInstruction({
        isToggle: true,
        value: false,
        comment: line.comment
    });
}
function fromM109(line: GCodeLine): SetToolheadTemperatureInstruction {
    return new SetToolheadTemperatureInstruction({
        toolhead: line.t,
        temperature: (line.s === undefined ? null : line.s),
        maxTargetTemperature: line.r,
        stabilize: true,
        comment: line.comment
    });
}
function fromM112(line: GCodeLine): EmergencyStopInstruction {
    return new EmergencyStopInstruction({
        comment: line.comment
    });
}
function fromM114(line: GCodeLine): GetPositionInstruction {
    return new GetPositionInstruction({
        comment: line.comment
    });
}
export function fromM116(line: GCodeLine): StabilizeTemperatureInstruction {
    if (line.p === undefined) {
        return new StabilizeAllTemperaturesInstruction({
            comment: line.comment
        });
    }
    return new StabilizeToolheadTemperatureInstruction({
        toolhead: line.p,
        comment: line.comment
    });
}
export function fromM117(line: GCodeLine): DisplayMessageInstruction {
    return new DisplayMessageInstruction({
        message: line.message,
        comment: line.comment
    });
}
function fromM135(line: GCodeLine): SetPIDSampleIntervalInstruction {
    return new SetPIDSampleIntervalInstruction({
        interval: line.s,
        comment: line.comment
    });
}
function fromM140(line: GCodeLine): BedStandbyInstruction | SetBedTemperatureInstruction {
    if (line.s === undefined) {
        return new BedStandbyInstruction({
            exitStandby: true,
            comment: line.comment
        });
    }
    return new SetBedTemperatureInstruction({
        temperature: line.s,
        bedNumber: line.t,
        heaterNumber: line.h,
        stabilize: false,
        comment: line.comment
    });
}
function fromM144(line: GCodeLine): BedStandbyInstruction {
    return new BedStandbyInstruction({
        comment: line.comment
    });
}
function fromM190(line: GCodeLine): SetBedTemperatureInstruction {
    return new SetBedTemperatureInstruction({
        temperature: line.s,
        maxTargetTemperature: line.r,
        stabilize: true,
        comment: line.comment
    });
}
export function fromM201(line: GCodeLine): SetMaxPrintAccelerationInstruction {
    return new SetMaxPrintAccelerationInstruction({
        x: line.x,
        y: line.y,
        z: line.z,
        extrusion: line.e,
        comment: line.comment,
    });
}
function fromM203(line: GCodeLine): SetMaxFeedrateInstruction {
    return new SetMaxFeedrateInstruction({
        x: line.x,
        y: line.y,
        z: line.z,
        extrusion: line.e,
        comment: line.comment,
    });
}
function fromM206(line: GCodeLine): OffsetAxisInstruction {
    return new OffsetAxisInstruction({
        x: line.x,
        y: line.y,
        z: line.z,
        comment: line.comment
    });
}
function fromM207(line: GCodeLine): SetRetractLengthInstruction {
    return new SetRetractLengthInstruction({
        retractLength: line.s,
        unretractLengthOffset: line.r,
        retractFeedrate: line.f,
        unretractFeedrate: line.t,
        zLift: line.z,
        comment: line.comment
    });
}
function fromM208(line: GCodeLine): SetAxisTravelBoundInstruction {
    return new SetAxisTravelBoundInstruction({
        isMaximum: (line.s !== 1),
        x: line.x,
        y: line.y,
        z: line.z,
        comment: line.comment
    });
}
function fromM220(line: GCodeLine): SetSpeedOverrideInstruction {
    return new SetSpeedOverrideInstruction({
        percentage: line.s,
        comment: line.comment
    });
}
function fromM221(line: GCodeLine): SetExtrusionOverrideInstruction {
    return new SetExtrusionOverrideInstruction({
        percentage: line.s,
        toolhead: <number> line.d,
        comment: line.comment
    });
}
function fromM226(line: GCodeLine): PauseInstruction {
    return new PauseInstruction({
        comment: line.comment
    });
}
export function fromM300(line: GCodeLine): PlayBeepInstruction {
    return new PlayBeepInstruction({
        frequency: line.s,
        duration: line.p,
        comment: line.comment
    });
}
function fromM400(line: GCodeLine): FinishBufferInstruction {
    return new FinishBufferInstruction({
        comment: line.comment
    });
}
function fromM564(line: GCodeLine): LimitAxisTravelInstruction {
    return new LimitAxisTravelInstruction({
        enabled: line.s === 1,
        comment: line.comment
    });
}
function fromM566(line: GCodeLine): SetMaxJerkSpeedInstruction {
    return new SetMaxJerkSpeedInstruction({
        x: line.x,
        y: line.y,
        z: line.z,
        extrusion: line.e,
        comment: line.comment
    });
}

/**
 * RaftInstruction-to-GCode translation functions
 */

function fromLinearMove(instruction: LinearMoveInstruction): GCodeLine {
    return {
        command: instruction.isRapidMove ? "G0" : "G1",
        x: (instruction.x === null ? undefined : instruction.x),
        y: (instruction.y === null ? undefined : instruction.y),
        z: (instruction.z === null ? undefined : instruction.z),
        e: (instruction.extrusion === null ? undefined : instruction.extrusion),
        f: (instruction.feedrate === null ? undefined : instruction.feedrate),
        comment: instruction.comment
    };
}
function fromArcMove(instruction: ArcMoveInstruction): GCodeLine {
    return {
        command: instruction.clockwise ? "G2" : "G3",
        x: (instruction.x === null ? undefined : instruction.x),
        y: (instruction.y === null ? undefined : instruction.y),
        i: (instruction.i === null ? undefined : instruction.i),
        j: (instruction.j === null ? undefined : instruction.j),
        e: (instruction.extrusion === null ? undefined : instruction.extrusion),
        f: (instruction.feedrate === null ? undefined : instruction.feedrate),
        comment: instruction.comment
    };
}
function fromDwell(instruction: DwellInstruction): GCodeLine {
    if (instruction.useMilliseconds) {
        return {
            command: "G4",
            p: instruction.duration,
            comment: instruction.comment
        };
    } else {
        return {
            command: "G4",
            s: instruction.duration,
            comment: instruction.comment
        };
    }
}
function fromSetToolOffset(instruction: SetToolOffsetInstruction): GCodeLine {
    return {
        command: "G10",
        p: (instruction.toolhead === null ? undefined : instruction.toolhead),
        x: (instruction.x === null ? undefined : instruction.x),
        y: (instruction.y === null ? undefined : instruction.y),
        z: (instruction.z === null ? undefined : instruction.z),
        comment: instruction.comment
    };
}
function fromRetract(instruction: RetractInstruction): GCodeLine {
    return {
        command: instruction.isUnretract ? "G11" : "G10",
        comment: instruction.comment
    };
}
function fromSetUnits(instruction: SetUnitsInstruction): GCodeLine {
    return {
        command: instruction.units === DistanceUnits.Inches ? "G20" : "G21",
        comment: instruction.comment
    };
}
function fromHome(instruction: HomeInstruction): GCodeLine {
    if (instruction.x === true && instruction.y === true && instruction.z === true) {
        return {
            command: "G28",
            comment: instruction.comment
        }
    }
    return {
        command: "G28",
        x: (instruction.x === false ? undefined : (instruction.x === true ? null : instruction.x)),
        y: (instruction.y === false ? undefined : (instruction.y === true ? null : instruction.y)),
        z: (instruction.z === false ? undefined : (instruction.z === true ? null : instruction.z)),
        comment: instruction.comment
    };
}
function fromZProbe(instruction: ZProbeInstruction): Object {
    return {
        original: instruction.original,
        comment: instruction.comment
    };
}
function fromSetCoordinateMode(instruction: SetCoordinateModeInstruction): GCodeLine {
    if (instruction.xyz === CoordinateModes.None) {
        // command to set extrusion coordinate mode
        return {
            command: (instruction.extrusion === CoordinateModes.Absolute ? "M82" : "M83"),
            comment: instruction.comment
        };
    } else {
        // command to set X/Y/Z coordinate mode
        return {
            command: (instruction.xyz === CoordinateModes.Absolute ? "G90" : "G91"),
            comment: instruction.comment
        };
    }
}
function fromSetPosition(instruction: SetPositionInstruction): GCodeLine {
    if (instruction.x === null && instruction.y === null && instruction.z === null && instruction.extrusion === null) {
        return {
            command: "G92",
            comment: instruction.comment
        }
    }
    return {
        command: "G92",
        x: (instruction.x === null ? undefined : instruction.x),
        y: (instruction.y === null ? undefined : instruction.y),
        z: (instruction.z === null ? undefined : instruction.z),
        e: (instruction.extrusion === null ? undefined : instruction.extrusion),
        comment: instruction.comment
    };
}

export function fromToolChange(instruction: ToolChangeInstruction): GCodeLine {
    return {
        command: "T" + instruction.toolhead,
        comment: instruction.comment
    };
}

function fromStop(instruction: StopInstruction): GCodeLine {
    if (instruction.keepHeatersActive === null) {
        return {
            command: "M0",
            comment: instruction.comment
        };
    }
    return {
        command: "M0",
        h: instruction.keepHeatersActive ? 1 : 0,
        comment: instruction.comment
    };
}
function fromSleep(instruction: SleepInstruction): GCodeLine {
    return {
        command: "M1",
        comment: instruction.comment
    };
}
function fromDisableStepperMotor(instruction: DisableStepperMotorInstruction): GCodeLine {
    if (instruction.x === null && instruction.y === null && instruction.z === null
        && instruction.a === null && instruction.b === null && instruction.e === null) {
        return {
            command: "M18",
            comment: instruction.comment
        }
    }
    return {
        command: "M18",
        x: (instruction.x === null ? undefined : 0),
        y: (instruction.y === null ? undefined : 0),
        z: (instruction.z === null ? undefined : 0),
        a: (instruction.a === null ? undefined : 0),
        b: (instruction.b === null ? undefined : 0),
        e: (instruction.e === null ? undefined : 0),
        comment: instruction.comment
    };
}
function fromStartSDPrint(instruction: StartSDPrintInstruction): GCodeLine {
    return {
        command: "M24",
        comment: instruction.comment
    };
}
function fromPauseSDPrint(instruction: PauseSDPrintInstruction): GCodeLine {
    return {
        command: "M25",
        comment: instruction.comment
    };
}
function fromStopIdleHold(instruction: StopIdleHoldInstruction): GCodeLine {
    return {
        command: "M84",
        s: (instruction.timeout === null ? undefined : instruction.timeout),
        comment: instruction.comment
    };
}
function fromSetToolheadTemperature(instruction: SetToolheadTemperatureInstruction): GCodeLine {
    if (instruction.stabilize) {
        return {
            command: "M109",
            t: (instruction.toolhead === null ? undefined : instruction.toolhead),
            s: (instruction.temperature === null ? undefined : instruction.temperature),
            r: (instruction.maxTargetTemperature === null ? undefined : instruction.maxTargetTemperature),
            comment: instruction.comment
        };
    } else {
        return {
            command: "M104",
            t: (instruction.toolhead === null ? undefined : instruction.toolhead),
            s: (instruction.temperature === null ? undefined : instruction.temperature),
            comment: instruction.comment
        };
    }
}
function fromSetFan(instruction: SetFanInstruction): GCodeLine {
    if (instruction.isToggle) {
        return {
            command: "M107",
            comment: instruction.comment
        };
    }
    return {
        command: "M106",
        p: (instruction.fanNumber === null ? undefined : instruction.fanNumber),
        s: instruction.value,
        comment: instruction.comment
    };
}
function fromEmergencyStop(instruction: EmergencyStopInstruction): GCodeLine {
    return {
        command: "M112",
        comment: instruction.comment
    };
}
function fromGetPosition(instruction: GetPositionInstruction): GCodeLine {
    return {
        command: "M114",
        comment: instruction.comment
    };
}
function fromStabilizeTemperature(instruction: StabilizeTemperatureInstruction): GCodeLine {
    if (instruction instanceof StabilizeToolheadTemperatureInstruction) {
        return {
            command: "M116",
            p: instruction.toolhead,
            comment: instruction.comment
        };
    }
    return {
        command: "M116",
        comment: instruction.comment
    };
}
function fromDisplayMessage(instruction: DisplayMessageInstruction): GCodeLine {
    return {
        command: "M117",
        message: instruction.message,
        comment: instruction.comment
    };
}
function fromSetPIDSampleInterval(instruction: SetPIDSampleIntervalInstruction): GCodeLine {
    return {
        command: "M135",
        s: instruction.interval,
        comment: instruction.comment
    };
}
function fromBedStandby(instruction: BedStandbyInstruction): GCodeLine {
    if (instruction.exitStandby) {
        return {
            command: "M140",
            comment: instruction.comment
        };
    }
    return {
        command: "M144",
        comment: instruction.comment
    };
}
function fromSetBedTemperature(instruction: SetBedTemperatureInstruction): GCodeLine {
    if (instruction.stabilize) {
        return {
            command: "M190",
            s: (instruction.temperature === null ? undefined : instruction.temperature),
            r: (instruction.maxTargetTemperature === null ? undefined : instruction.maxTargetTemperature),
            comment: instruction.comment
        };
    } else {
        return {
            command: "M140",
            s: instruction.temperature,
            t: (instruction.bedNumber === null ? undefined : instruction.bedNumber),
            h: (instruction.heaterNumber === null ? undefined : instruction.heaterNumber),
            comment: instruction.comment
        };
    }
}
function fromSetMaxPrintAcceleration(instruction: SetMaxPrintAccelerationInstruction): GCodeLine {
    return {
        command: "M201",
        x: (instruction.x === null ? undefined : instruction.x),
        y: (instruction.y === null ? undefined : instruction.y),
        z: (instruction.z === null ? undefined : instruction.z),
        e: (instruction.extrusion === null ? undefined : instruction.extrusion),
        comment: instruction.comment
    };
}
function fromSetMaxFeedrate(instruction: SetMaxFeedrateInstruction): GCodeLine {
    return {
        command: "M203",
        x: (instruction.x === null ? undefined : instruction.x),
        y: (instruction.y === null ? undefined : instruction.y),
        z: (instruction.z === null ? undefined : instruction.z),
        e: (instruction.extrusion === null ? undefined : instruction.extrusion),
        comment: instruction.comment
    };
}
function fromOffsetAxis(instruction: OffsetAxisInstruction): GCodeLine {
    return {
        command: "M206",
        x: (instruction.x === null ? undefined : instruction.x),
        y: (instruction.y === null ? undefined : instruction.y),
        z: (instruction.z === null ? undefined : instruction.z),
        comment: instruction.comment
    };
}
function fromSetRetractLength(instruction: SetRetractLengthInstruction): GCodeLine {
    return {
        command: "M207",
        s: (instruction.retractLength === null ? undefined : instruction.retractLength),
        r: (instruction.unretractLengthOffset === null ? undefined : instruction.unretractLengthOffset),
        f: (instruction.retractFeedrate === null ? undefined : instruction.retractFeedrate),
        t: (instruction.unretractFeedrate === null ? undefined : instruction.unretractFeedrate),
        z: (instruction.zLift === null ? undefined : instruction.zLift),
        comment: instruction.comment
    };
}
function fromSetAxisTravelBound(instruction: SetAxisTravelBoundInstruction): GCodeLine {
    return {
        command: "M208",
        s: instruction.isMaximum ? undefined : 1,
        x: (instruction.x === null ? undefined : instruction.x),
        y: (instruction.y === null ? undefined : instruction.y),
        z: (instruction.z === null ? undefined : instruction.z),
        comment: instruction.comment
    };
}
function fromSetSpeedOverride(instruction: SetSpeedOverrideInstruction): GCodeLine {
    return {
        command: "M220",
        s: instruction.percentage,
        comment: instruction.comment
    };
}
function fromSetExtrusionOverride(instruction: SetExtrusionOverrideInstruction): GCodeLine {
    return {
        command: "M221",
        s: instruction.percentage,
        d: instruction.toolhead === null ? undefined : instruction.toolhead,
        comment: instruction.comment
    };
}
function fromPause(instruction: PauseInstruction): GCodeLine {
    return {
        command: "M226",
        comment: instruction.comment
    };
}
function fromPlayBeep(instruction: PlayBeepInstruction): GCodeLine {
    return {
        command: "M300",
        s: instruction.frequency,
        p: instruction.duration,
        comment: instruction.comment
    };
}
function fromFinishBuffer(instruction: FinishBufferInstruction): GCodeLine {
    return {
        command: "M400",
        comment: instruction.comment
    };
}
function fromLimitAxisTravel(instruction: LimitAxisTravelInstruction): GCodeLine {
    return {
        command: "M564",
        s: instruction.enabled ? 1 : 0,
        comment: instruction.comment
    };
}
function fromSetMaxJerkSpeed(instruction: SetMaxJerkSpeedInstruction): GCodeLine {
    return {
        command: "M566",
        x: (instruction.x === null ? undefined : instruction.x),
        y: (instruction.y === null ? undefined : instruction.y),
        z: (instruction.z === null ? undefined : instruction.z),
        e: (instruction.extrusion === null ? undefined : instruction.extrusion),
        comment: instruction.comment
    };
}

function fromOStartMulticolor(instruction: OStartMulticolorInstruction): GCodeLine {
    return {
        command: "",
        original: "O1 D" + instruction.filename + " D" + floatToHexString(instruction.printLength),
        comment: instruction.comment
    };
}
function fromOSoftReset(instruction: OSoftResetInstruction): GCodeLine {
    return {
        command: "O9",
        comment: instruction.comment
    };
}
function fromOVersion(instruction: OVersionInstruction): GCodeLine {
    const version = (instruction.major * 10) + instruction.minor;
    return {
        command: "O21",
        d: intToHexString(version, 4),
        comment: instruction.comment
    };
}
function fromOPrinterProfile(instruction: OPrinterProfileInstruction): GCodeLine {
    return {
        command: "O22",
        d: instruction.id,
        comment: instruction.comment
    };
}
function fromOSlicerProfile(instruction: OSlicerProfileInstruction): GCodeLine {
    return {
        command: "O23",
        d: instruction.id,
        comment: instruction.comment
    };
}
function fromOAdjustedPPM(instruction: OAdjustedPPMInstruction): GCodeLine {
    return {
        command: "O24",
        d: intToHexString(instruction.adjustment, 4),
        comment: instruction.comment
    };
}
function fromOMaterialsUsed(instruction: OMaterialsUsedInstruction): GCodeLine {
    let original = "O25";
    for (let material of instruction.materials) {
        original += " D";
        if (material.index === 0) {
            original += "0";
        } else {
            original += intToHexString(material.index, 1);
            original += intToHexString(material.color[0], 2);
            original += intToHexString(material.color[1], 2);
            original += intToHexString(material.color[2], 2);
            original += material.name;
        }
    }
    return {
        command: "",
        original: original,
        comment: instruction.comment
    };
}
function fromOSpliceCount(instruction: OSpliceCountInstruction): GCodeLine {
    return {
        command: "O26",
        d: intToHexString(instruction.count, 4),
        comment: instruction.comment
    };
}
function fromOPingCount(instruction: OPingCountInstruction): GCodeLine {
    return {
        command: "O27",
        d: intToHexString(instruction.count, 4),
        comment: instruction.comment
    };
}
function fromOAlgorithmCount(instruction: OAlgorithmCountInstruction): GCodeLine {
    return {
        command: "O28",
        d: intToHexString(instruction.count, 4),
        comment: instruction.comment
    };
}
function fromOHotSwapCount(instruction: OHotSwapCountInstruction): GCodeLine {
    return {
        command: "O29",
        d: intToHexString(instruction.count, 4),
        comment: instruction.comment
    };
}
function fromOSpliceData(instruction: OSpliceDataInstruction): GCodeLine {
    return {
        command: "",
        original: "O30 D" + instruction.drive + " D" + floatToHexString(instruction.length),
        comment: instruction.comment
    };
}
function fromOPingData(instruction: OPingDataInstruction): GCodeLine {
    let original = "O31 D" + floatToHexString(instruction.length);
    if (instruction.extrusion !== null) {
        original += " D" + floatToHexString(instruction.extrusion)
    }
    return {
        command: "",
        original: original,
        comment: instruction.comment
    };
}
function fromOAlgorithmData(instruction: OAlgorithmDataInstruction): GCodeLine {
    const original = "O32 D" + instruction.ingoing.toString() + instruction.outgoing.toString()
        + " D" + int16ToHexString(Math.round(instruction.heat))
        + " D" + int16ToHexString(Math.round(instruction.compression))
        + " D" + int16ToHexString(Math.round(instruction.cooling));
    return {
        command: "",
        original: original,
        comment: instruction.comment
    };
}
function fromOHotSwapData(instruction: OHotSwapDataInstruction): GCodeLine {
    const original = "O33 D" + floatToHexString(instruction.drive)
        + " D" + floatToHexString(instruction.length)
        + " D" + instruction.materialIndex;
    return {
        command: "",
        original: original,
        comment: instruction.comment
    };
}
