/**
 * @module RaftEngine
 */ /** */

import RaftInstruction from "../instructions/base"
import InvalidInstructionError from "../errors/invalid-instruction";
import {RaftState} from "../state-machines/base";
import {isNullOrUndefined} from "util";
import UnknownInstruction from "../instructions/unknown";

export interface RaftEngineOptions {
    skipInvalidInstructions?: boolean
}

abstract class RaftEngine {

    protected stateMachines: Object;
    protected config: RaftEngineOptions = {
        skipInvalidInstructions: false
    };

    public constructor(options: RaftEngineOptions) {
        if (!isNullOrUndefined(options.skipInvalidInstructions)) {
            this.config.skipInvalidInstructions = options.skipInvalidInstructions;
        }
        this.stateMachines = {};
    }

    public abstract clone(): RaftEngine;

    /**
     * FINAL
     */
    protected copyStateMachinesTo(engine): void {
        let keys = Object.keys(this.stateMachines);
        for (let key of keys) {
            engine.stateMachines[key] = this.stateMachines[key].clone();
        }
        engine.config.skipInvalidInstructions = this.config.skipInvalidInstructions;
    }

    /**
     * FINAL
     */
    public getCurrentState(): Map<string, RaftState> {
        let keys = Object.keys(this.stateMachines);
        let map = new Map<string, RaftState>();
        for (let key of keys) {
            map.set(key, this.stateMachines[key].getCurrentState());
        }
        return map;
    }

    public toRaftInstruction(line: Object): RaftInstruction {
        return unknownInstruction(line, this.config);
    }

    public toOutputInstruction(instruction: RaftInstruction): Object {
        if (instruction instanceof UnknownInstruction) {
            return {
                original: instruction.original,
                comment: instruction.comment
            };
        }
        return {
            comment: instruction.comment
        };
    }

    /**
     * FINAL
     */
    public needsExecuteForNextInstruction(): boolean {
        let keys = Object.keys(this.stateMachines);
        let anyStateMachine = this.stateMachines[keys[0]];
        return anyStateMachine.futureIsEmpty();
    }

    public executeNext(instruction: RaftInstruction): void {
        let keys = Object.keys(this.stateMachines);
        for (let key of keys) {
            if (!this.stateMachines[key].stateInserted) {
                this.stateMachines[key].insertCurrentState();
            }
            this.stateMachines[key].stateInserted = false;
        }
    }

    /**
     * FINAL
     */
    public stepForward(): void {
        let keys = Object.keys(this.stateMachines);
        for (let key of keys) {
            this.stateMachines[key].stepForward();
        }
    }

    /**
     * FINAL
     */
    public stepBackward(): void {
        let keys = Object.keys(this.stateMachines);
        for (let key of keys) {
            this.stateMachines[key].stepBackward();
        }
    }

    /**
     * FINAL
     */
    public invalidateFuture(): void {
        let keys = Object.keys(this.stateMachines);
        for (let key of keys) {
            this.stateMachines[key].invalidateFuture();
        }
    }

    toString(): string {
        return "RaftEngine";
    }

}

export function unknownInstruction(line: any, config: RaftEngineOptions): RaftInstruction {
    if (config.skipInvalidInstructions) {
        return new UnknownInstruction({
            original: line.original
        });
    } else {
        throw new InvalidInstructionError("Invalid/unknown instruction encountered", line.original);
    }
}

export default RaftEngine;
