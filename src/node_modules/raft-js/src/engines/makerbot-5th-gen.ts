/**
 * @module RaftEngine
 */ /** */

import RaftEngine, {RaftEngineOptions} from "./base";
import RaftInstruction from "../instructions/base"
import LinearMoveInstruction from "../instructions/linear-move";
import SetFanInstruction from "../instructions/set-fan";
import SetToolheadTemperatureInstruction from "../instructions/set-toolhead-temperature";
import {Makerbot5thGenLine} from "../parsers/makerbot";
import InvalidInstructionError from "../errors/invalid-instruction";
import EmptyInstruction from "../instructions/empty";
import OffsetAxisStateMachine, {OffsetAxisState} from "../state-machines/offset-axis";
import {CoordinateModes, PrintStates} from "../enums";
import ExtrusionAxisStateMachine, {ExtrusionAxisState} from "../state-machines/extrusion-axis";
import NonNegativeAxisStateMachine, {NonNegativeAxisState} from "../state-machines/non-negative-axis";
import StandbyAxisStateMachine, {StandbyAxisState} from "../state-machines/standby-axis";
import {isNullOrUndefined} from "util";
import PrintStateMachine, {PrintState} from "../state-machines/print";
import {roundTo} from "../common/math";

export interface Makerbot5thGenEngineOptions extends RaftEngineOptions {
    // initial X/Y/Z state parameters
    initialXYZCoordinateMode: CoordinateModes.Absolute | CoordinateModes.Relative

    // initial extrusion state parameters
    initialExtrusionCoordinateMode: CoordinateModes.Absolute | CoordinateModes.Relative

    // initial print feature state parameters
    initialPrintState?: PrintStates
}

export default class Makerbot5thGenEngine extends RaftEngine {

    public lastX: number;
    public lastY: number;
    public lastZ: number;
    public lastFeedrate: number;

    public constructor(options: Makerbot5thGenEngineOptions) {
        super(options);
        this.lastX = 0;
        this.lastY = 0;
        this.lastZ = 0;
        this.lastFeedrate = 0;
        this.stateMachines["x"] = new OffsetAxisStateMachine(new OffsetAxisState({
            coordinateMode: options.initialXYZCoordinateMode,
            position: null,
            offset: 0
        }));
        this.stateMachines["y"] = new OffsetAxisStateMachine(new OffsetAxisState({
            coordinateMode: options.initialXYZCoordinateMode,
            position: null,
            offset: 0
        }));
        this.stateMachines["z"] = new OffsetAxisStateMachine(new OffsetAxisState({
            coordinateMode: options.initialXYZCoordinateMode,
            position: null,
            offset: 0
        }));
        this.stateMachines["extrusion"] = new ExtrusionAxisStateMachine(new ExtrusionAxisState({
            coordinateMode: options.initialExtrusionCoordinateMode,
            position: null,
            totalDispensed: 0,
            retraction: 0,
            retractDistance: null,
            unretractExtraLength: null
        }));
        this.stateMachines["feedrate"] = new NonNegativeAxisStateMachine(new NonNegativeAxisState({
            position: null
        }));
        this.stateMachines["extruderTemp"] = new StandbyAxisStateMachine(new StandbyAxisState({
            position: null,
            standby: true
        }));
        this.stateMachines["fan"] = new NonNegativeAxisStateMachine(new NonNegativeAxisState({
            position: null
        }));
        this.stateMachines["printState"] = new PrintStateMachine(new PrintState({
            value: isNullOrUndefined(options.initialPrintState) ? PrintStates.None : options.initialPrintState
        }));
    }

    public clone(): Makerbot5thGenEngine {
        let copy = new Makerbot5thGenEngine({
            initialXYZCoordinateMode: this.stateMachines["x"].getCurrentState().coordinateMode,
            initialExtrusionCoordinateMode: this.stateMachines["extrusion"].getCurrentState().coordinateMode
        });
        this.copyStateMachinesTo(copy);
        return copy;
    }

    public toRaftInstruction(line: Makerbot5thGenLine): RaftInstruction {
        switch (line.command.function) {
            case "move":
                return fromJSONMove(line);
            case "comment":
                return fromJSONComment(line);
            case "set_toolhead_temperature":
                return fromJSONSetToolheadTemperature(line);
            case "fan_duty":
                return fromJSONFanDuty(line);
            case "toggle_fan":
                return fromJSONToggleFan(line);
        }
        if (this.config.skipInvalidInstructions) {
            return super.toRaftInstruction(line);
        } else {
            throw new InvalidInstructionError("Unknown instruction encountered", line.command.function);
        }
    }

    public toOutputInstruction(instruction: RaftInstruction): Makerbot5thGenLine {
        if (instruction instanceof LinearMoveInstruction) return fromLinearMove(instruction, this);
        if (instruction instanceof EmptyInstruction) return fromEmpty(instruction);
        if (instruction instanceof SetToolheadTemperatureInstruction) return fromSetToolheadTemperature(instruction);
        if (instruction instanceof SetFanInstruction) return fromSetFan(instruction);
        return null;
    }

    public executeNext(instruction: RaftInstruction): void {

        if (instruction instanceof LinearMoveInstruction) {

            if (!this.stateMachines["x"].stateInserted && instruction.x !== null) {
                let currentXState: OffsetAxisState = this.stateMachines["x"].getCurrentState();
                let newXPosition = currentXState.position || 0;
                if (instruction.relativeX) {
                    newXPosition += instruction.x;
                } else {
                    newXPosition = instruction.x;
                }
                this.stateMachines["x"].insertState(new OffsetAxisState({
                    coordinateMode: currentXState.coordinateMode,
                    offset: currentXState.offset,
                    position: newXPosition
                }));
                this.stateMachines["x"].stateInserted = true;
            }

            if (!this.stateMachines["y"].stateInserted && instruction.y !== null) {
                let currentYState: OffsetAxisState = this.stateMachines["y"].getCurrentState();
                let newYPosition = currentYState.position || 0;
                if (instruction.relativeY) {
                    newYPosition += instruction.y;
                } else {
                    newYPosition = instruction.y;
                }
                this.stateMachines["y"].insertState(new OffsetAxisState({
                    coordinateMode: currentYState.coordinateMode,
                    offset: currentYState.offset,
                    position: newYPosition
                }));
                this.stateMachines["y"].stateInserted = true;
            }

            if (!this.stateMachines["z"].stateInserted && instruction.z !== null) {
                let currentZState: OffsetAxisState = this.stateMachines["z"].getCurrentState();
                let newZPosition = currentZState.position || 0;
                if (instruction.relativeZ) {
                    newZPosition += instruction.z;
                } else {
                    newZPosition = instruction.z;
                }
                this.stateMachines["z"].insertState(new OffsetAxisState({
                    coordinateMode: currentZState.coordinateMode,
                    offset: currentZState.offset,
                    position: newZPosition
                }));
                this.stateMachines["z"].stateInserted = true;
            }

            if (!this.stateMachines["feedrate"].stateInserted && instruction.feedrate !== null) {
                this.stateMachines["feedrate"].insertState(new NonNegativeAxisState({
                    position: instruction.feedrate
                }));
                this.stateMachines["feedrate"].stateInserted = true;
            }

            if (!this.stateMachines["extrusion"].stateInserted && instruction.extrusion !== null) {

                let currentEState: ExtrusionAxisState = this.stateMachines["extrusion"].getCurrentState();
                let newEPosition = currentEState.position || 0;
                let newTotalDispensed = currentEState.totalDispensed;
                let newRetraction = currentEState.retraction;

                if (instruction.relativeExtrusion) {
                    if (instruction.extrusion < 0) {
                        // relative, negative extrusion
                        newEPosition += instruction.extrusion;
                        newRetraction -= instruction.extrusion;
                    } else if (instruction.extrusion > 0) {
                        // relative, positive extrusion
                        newEPosition += instruction.extrusion;
                        newRetraction = Math.max(0, currentEState.retraction - instruction.extrusion);
                        if (newRetraction === 0) {
                            newTotalDispensed += instruction.extrusion - currentEState.retraction;
                        }
                    }
                } else {
                    let positionDelta = instruction.extrusion - currentEState.position;
                    if (instruction.extrusion < currentEState.position) {
                        // absolute, negative extrusion
                        newEPosition = instruction.extrusion;
                        newRetraction -= positionDelta;
                    } else if (instruction.extrusion > currentEState.position) {
                        // absolute, positive extrusion
                        newEPosition = instruction.extrusion;
                        newRetraction = Math.max(0, currentEState.retraction - positionDelta);
                        if (newRetraction === 0) {
                            newTotalDispensed += positionDelta - currentEState.retraction;
                        }
                    }
                }

                this.stateMachines["extrusion"].insertState(new ExtrusionAxisState({
                    coordinateMode: currentEState.coordinateMode,
                    retractDistance: currentEState.retractDistance,
                    unretractExtraLength: currentEState.unretractExtraLength,
                    position: newEPosition,
                    totalDispensed: newTotalDispensed,
                    retraction: newRetraction,
                }));
                this.stateMachines["extrusion"].stateInserted = true;
            }

        }

        if (instruction instanceof SetToolheadTemperatureInstruction) {

            if (!this.stateMachines["extruderTemp"].stateInserted) {
                let currentTempState: StandbyAxisState = this.stateMachines["extruderTemp"].getCurrentState();
                this.stateMachines["extruderTemp"].insertState(new StandbyAxisState({
                    position: instruction.temperature,
                    standby: currentTempState.standby
                }));
                this.stateMachines["extruderTemp"].stateInserted = true;
            }

        }

        if (instruction instanceof SetFanInstruction) {

            if (!this.stateMachines["fan"].stateInserted) {
                this.stateMachines["fan"].insertState(new NonNegativeAxisState({
                    position: instruction.value
                }));
                this.stateMachines["fan"].stateInserted = true;
            }

        }

        super.executeNext(instruction);
    }

    public toString(): string {
        return "MakerbotEngine";
    }

}

/**
 * JSON-to-RaftInstruction translation functions
 */

function fromJSONMove(line: Makerbot5thGenLine): LinearMoveInstruction {
    return new LinearMoveInstruction({
        x: line.command.parameters.x,
        y: line.command.parameters.y,
        z: line.command.parameters.z,
        extrusion: line.command.parameters.a,
        relativeX: line.command.metadata.relative.x,
        relativeY: line.command.metadata.relative.y,
        relativeZ: line.command.metadata.relative.z,
        relativeExtrusion: line.command.metadata.relative.a,
        feedrate: line.command.parameters.feedrate,
        isRapidMove: true
    });
}
function fromJSONComment(line: Makerbot5thGenLine): EmptyInstruction {
    return new EmptyInstruction({
        comment: line.command.parameters.comment
    });
}
function fromJSONSetToolheadTemperature(line: Makerbot5thGenLine): SetToolheadTemperatureInstruction {
    return new SetToolheadTemperatureInstruction({
        temperature: line.command.parameters.temperature,
        stabilize: true
    });
}
function fromJSONFanDuty(line: Makerbot5thGenLine): SetFanInstruction {
    return new SetFanInstruction({
        isToggle: false,
        value: line.command.parameters.value
    });
}
function fromJSONToggleFan(line: Makerbot5thGenLine): SetFanInstruction {
    return new SetFanInstruction({
        isToggle: true,
        value: line.command.parameters.value
    });
}

/**
 * RaftInstruction-to-GCode translation functions
 */

function fromLinearMove(instruction: LinearMoveInstruction, _this: Makerbot5thGenEngine): Makerbot5thGenLine {
    if (instruction.x !== null) _this.lastX = instruction.x;
    if (instruction.y !== null) _this.lastY = instruction.y;
    if (instruction.z !== null) _this.lastZ = instruction.z;
    if (instruction.feedrate !== null) _this.lastFeedrate = instruction.feedrate;
    return {
        command: {
            "function": "move",
            parameters: {
                x: instruction.x === null ? _this.lastX : instruction.x,
                y: instruction.y === null ? _this.lastY : instruction.y,
                z: instruction.z === null ? _this.lastZ : instruction.z,
                a: instruction.extrusion === null ? 0 : instruction.extrusion,
                feedrate: instruction.feedrate === null ? _this.lastFeedrate : instruction.feedrate,
            },
            metadata: {
                relative: {
                    x: instruction.relativeX || ((<OffsetAxisState> _this.getCurrentState().get("x")).coordinateMode === CoordinateModes.Relative),
                    y: instruction.relativeY || ((<OffsetAxisState> _this.getCurrentState().get("y")).coordinateMode === CoordinateModes.Relative),
                    z: instruction.relativeZ || ((<OffsetAxisState> _this.getCurrentState().get("z")).coordinateMode === CoordinateModes.Relative),
                    a: instruction.relativeExtrusion || ((<ExtrusionAxisState> _this.getCurrentState().get("extrusion")).coordinateMode === CoordinateModes.Relative),
                }
            },
            tags: []
        }
    };
}
function fromEmpty(instruction: EmptyInstruction): Makerbot5thGenLine {
    return null;
    // return {
    //     command: {
    //         "function": "comment",
    //         parameters: {
    //             comment: instruction.comment.replace("\"", "").trim()
    //         },
    //         metadata: {},
    //         tags: []
    //     }
    // };
}
function fromSetToolheadTemperature(instruction: SetToolheadTemperatureInstruction): Makerbot5thGenLine {
    return {
        command: {
            "function": "set_toolhead_temperature",
            parameters: {
                temperature: instruction.temperature
            },
            metadata: {},
            tags: []
        }
    };
}
function fromSetFan(instruction: SetFanInstruction): Makerbot5thGenLine {
    if (instruction.isToggle) {
        return {
            command: {
                "function": "toggle_fan",
                parameters: {
                    value: !!instruction.value
                },
                metadata: {},
                tags: []
            }
        };
    }
    let value = instruction.value;
    if (value > 1) {
        value = roundTo(value / 255, 6);
    }
    return {
        command: {
            "function": "fan_duty",
            parameters: {
                value: value
            },
            metadata: {},
            tags: []
        }
    };
}
