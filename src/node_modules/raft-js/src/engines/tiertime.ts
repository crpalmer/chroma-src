/**
 * @module RaftEngine
 */ /** */

import RepRapEngine, {RepRapEngineOptions} from "./reprap";
import RaftInstruction from "../instructions/base";
import LinearMoveInstruction from "../instructions/linear-move";
import {CoordinateModes} from "../enums";
import SetRetractLengthInstruction from "../instructions/set-retract-length";
import {ExtrusionAxisState} from "../state-machines/extrusion-axis";
import RetractInstruction from "../instructions/retract";
import ArcMoveInstruction from "../instructions/arc-move";
import MoveInstruction from "../instructions/move";
import EmptyInstruction from "../instructions/empty";
import {GCodeLine} from "../parsers/gcode";
import {unknownInstruction} from "./base";

export interface TiertimeEngineOptions extends RepRapEngineOptions {
    extruderStepsPerMM: number
}

export default class TiertimeEngine extends RepRapEngine {

    public readonly extruderStepsPerMM: number;

    public constructor(options?: TiertimeEngineOptions) {
        options.volumetricExtrusion = false;
        super(options);
        this.extruderStepsPerMM = options.extruderStepsPerMM;
    }

    public clone(): TiertimeEngine {
        let copy = new TiertimeEngine({
            toolheadCount: this.toolheadCount,
            independentExtruders: this.independentExtruders,
            volumetricExtrusion: this.volumetricExtrusion,
            defaultHomeDirectionMax: this.defaultHomeDirectionMax,
            filamentDiameter: this.filamentDiameter,
            initialXYZCoordinateMode: this.stateMachines["x"].getCurrentState().coordinateMode,
            initialExtrusionCoordinateMode: this.stateMachines["extrusion"].getCurrentState().coordinateMode,
            extruderStepsPerMM: this.extruderStepsPerMM
        });
        this.copyStateMachinesTo(copy);
        return copy;
    }

    public toRaftInstruction(line: GCodeLine): RaftInstruction {

        if (!line.command) {
            return new EmptyInstruction({
                comment: line.comment
            });
        }

        if (line.command === "G28") return unknownInstruction(line, this.config);

        return super.toRaftInstruction(line);
    }

    public executeNext(instruction: RaftInstruction): void {

        if (instruction instanceof LinearMoveInstruction || instruction instanceof ArcMoveInstruction) {

            if (!this.stateMachines["extrusion"].stateInserted && instruction.extrusion !== null) {
                let currentEState: ExtrusionAxisState = this.stateMachines["extrusion"].getCurrentState();
                let newEState = getNewExtrusionStateAfterMoveCommand(instruction, currentEState, this.extruderStepsPerMM);
                this.stateMachines["extrusion"].insertState(newEState);
                this.stateMachines["extrusion"].stateInserted = true;
            }

        }

        super.executeNext(instruction);

    }

    public toString(): string {
        return "TiertimeEngine";
    }

}

export function getNewExtrusionStateAfterMoveCommand(
    instruction: MoveInstruction,
    currentState: ExtrusionAxisState,
    extruderStepsPerMM: number): ExtrusionAxisState {

    let newEPosition = currentState.position || 0;
    let newTotalDispensed = currentState.totalDispensed;
    let newRetraction = currentState.retraction;

    if (currentState.coordinateMode === CoordinateModes.Relative) {
        if (instruction.extrusion < 0) {
            // relative, negative extrusion
            newEPosition += instruction.extrusion;
            newRetraction -= instruction.extrusion;
        } else if (instruction.extrusion > 0) {
            // relative, positive extrusion
            newEPosition += instruction.extrusion;
            newRetraction = Math.max(0, (currentState.retraction - instruction.extrusion));
            if (newRetraction === 0) {
                newTotalDispensed += (instruction.extrusion - currentState.retraction) / extruderStepsPerMM;
            }
        }
    } else {
        let positionDelta = instruction.extrusion - currentState.position;
        if (instruction.extrusion < currentState.position) {
            // absolute, negative extrusion
            newEPosition = instruction.extrusion;
            newRetraction -= positionDelta;
        } else if (instruction.extrusion > currentState.position) {
            // absolute, positive extrusion
            newEPosition = instruction.extrusion;
            newRetraction = Math.max(0, (currentState.retraction - positionDelta));
            if (newRetraction === 0) {
                newTotalDispensed += (positionDelta - currentState.retraction) / extruderStepsPerMM;
            }
        }
    }

    return new ExtrusionAxisState({
        coordinateMode: currentState.coordinateMode,
        retractDistance: currentState.retractDistance,
        unretractExtraLength: currentState.unretractExtraLength,
        position: newEPosition,
        totalDispensed: newTotalDispensed,
        retraction: newRetraction,
    });

}
