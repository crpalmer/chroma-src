/**
 * @module RaftParser
 */ import RaftEngine from "../engines/base";
/** */

const Zip = require("node-zip");

import * as fs from "fs";
import JSONParser from "./json";
import FileTypeError from "../errors/file-type";
import RaftInstruction from "../instructions/base";

export interface Makerbot5thGenLine {
    command: {
        //noinspection ReservedWordAsName
        function: string,
        parameters: {
            x?: number,
            y?: number,
            z?: number,
            a?: number,
            feedrate?: number,
            temperature?: number,
            value?: number | boolean,
            comment?: string
        },
        metadata: {
            relative?: {
                x: boolean,
                y: boolean,
                z: boolean,
                a: boolean
            }
        },
        tags: string[]
    }
}

export default class MakerbotParser extends JSONParser {

    public thumbnailSmall: Buffer;
    public thumbnailMedium: Buffer;
    public thumbnailLarge: Buffer;
    public metaJson: Object;

    public constructor (engine: RaftEngine) {
        super(engine);
    }

    public clone(): MakerbotParser {
        return new MakerbotParser(this.engine.clone());
    }

    public parse(input: string | Buffer): RaftInstruction[] {
        let lines: Makerbot5thGenLine[] = JSON.parse(input.toString());
        let instructions: RaftInstruction[] = [];
        for (let line of lines) {
            instructions.push(this.engine.toRaftInstruction(line));
        }
        return instructions;
    }

    public toOutput(instructions: RaftInstruction[]): string | Buffer {
        let output: Makerbot5thGenLine[] = [];
        for (let instruction of instructions) {
            let line = <Makerbot5thGenLine> this.engine.toOutputInstruction(instruction);
            if (line !== null) {
                output.push(line);
            }
        }
        return (JSON.stringify(output, null, 0)
            .replace(/"command":/g, "\n\"command\" :"))
            .replace(/"function":/g, "\"function\" :")
            .replace(/:/g, ": ")
            .replace(/,/g, ", ");
    }

    public readFile(inpath: string): string|Buffer {
        if (!fs.existsSync(inpath)) {
            throw new FileTypeError("Input file path does not exist.");
        }
        let contents = fs.readFileSync(inpath);
        let zip = new Zip(contents);

        this.metaJson = JSON.parse(Buffer.from(zip.files["meta.json"]._data.getContent()).toString("utf-8"));
        this.thumbnailSmall = Buffer.from(zip.files["thumbnail_55x40.png"]._data.getContent());
        this.thumbnailMedium = Buffer.from(zip.files["thumbnail_110x80.png"]._data.getContent());
        this.thumbnailLarge = Buffer.from(zip.files["thumbnail_320x200.png"]._data.getContent());

        let printFile = Buffer.from(zip.files["print.jsontoolpath"]._data.getContent());
        return printFile.toString("utf-8");
    }

    public writeFile(outpath: string, contents: string|Buffer): void {
        let zip = new Zip();
        zip.file("meta.json", JSON.stringify(this.metaJson, null, 4));
        zip.file("thumbnail_55x40.png", this.thumbnailSmall);
        zip.file("thumbnail_110x80.png", this.thumbnailMedium);
        zip.file("thumbnail_320x200.png", this.thumbnailLarge);
        zip.file("print.jsontoolpath", contents);
        let data = zip.generate({
            base64: false,
            compression: "DEFLATE"
        });
        fs.writeFileSync(outpath, data, "binary");
    }

    toString(): string {
        return "MakerbotParser";
    }

}
