/**
 * @module RaftParser
 */ /** */

import ASCIIParser from "./ascii";
import RaftEngine from "../engines/base";
import RaftInstruction from "../instructions/base";
import InvalidArgumentError from "../errors/invalid-argument";
import InvalidInstructionError from "../errors/invalid-instruction";
import InstructionSyntaxError from "../errors/instruction-syntax";

export interface GCodeLine {
    command: string
    comment: string
    original?: string
    message?: string
    a?: number
    b?: number
    d?: number | string
    e?: number
    f?: number
    g?: number
    h?: number
    i?: number
    j?: number
    k?: string
    l?: number
    n?: number
    p?: number
    r?: number
    s?: number
    t?: number
    u?: number
    x?: number
    y?: number
    z?: number
}

export default class GCodeParser extends ASCIIParser {

    constructor (engine: RaftEngine) {
        super(engine);
    }

    public clone(): GCodeParser {
        return new GCodeParser(this.engine.clone());
    }

    public parse(input: string|Buffer): RaftInstruction[] {
        let lines = input.toString().split(/\r\n|\r|\n/);
        let instructions: RaftInstruction[] = [];
        for (let i = 0; i < lines.length; i++) {
            let line = lines[i];
            // collect line parameters
            let params: GCodeLine = {
                original: line,
                command: "",
                comment: ""
            };
            // store comments (starting with a semicolon, continuing to the end of the line)
            let comment = "";
            let commentSplit: string[] = line.split(";");
            line = commentSplit.shift().trim();
            if (commentSplit.length > 0) {
                comment += commentSplit.join(";");
            }
            // also store comments starting with a bracket, continuing to the rest of the line
            commentSplit = line.split("(");
            line = commentSplit.shift().trim();
            if (commentSplit.length > 0) {
                comment += "(" + commentSplit.join("(");
            }
            params.comment = comment;
            // split the line at spaces
            let lineParts: string[] = line.split(/ +/);
            if (lineParts.length > 0) {
                let command: string = lineParts.shift();
                if (command) {
                    params.command = command;
                }
                if (command.toUpperCase() === "M117") {
                    params.message = lineParts.join(" ");
                } else if (command.toUpperCase() === "M70") {
                    if (lineParts[0][0].toUpperCase() === "P") {
                        params.p = parseFloat(lineParts.shift().substr(1));
                    }
                    params.message = lineParts.join(" ");
                } else {
                    for (let part of lineParts) {
                        let key = part[0].toLowerCase();
                        let valString = part.substr(1).trim();
                        if (valString === "") {
                            params[key] = "";
                        } else if (valString.match(/^[-+]?(?:\d+|(?:\d*\.\d+))$/)) {
                            params[key] = parseFloat(valString);
                        } else {
                            params[key] = valString;
                        }
                    }
                }
            }
            try {
                instructions.push(this.engine.toRaftInstruction(params));
            } catch (e) {
                if ((e instanceof InvalidArgumentError) || (e instanceof InvalidInstructionError)) {
                    let lineNum = i + 1;
                    throw new InstructionSyntaxError(e.message, lineNum);
                } else {
                    throw e;
                }
            }
        }
        return instructions;
    }

    public toOutput(instructions: RaftInstruction[]): string|Buffer {
        let output: string[] = [];
        for (let instruction of instructions) {
            let params: GCodeLine = <GCodeLine> this.engine.toOutputInstruction(instruction);
            let line = "";
            let comment = "";
            if (params.comment) {
                comment = ";" + params.comment;
            }
            delete params.comment;
            if (params.command) {
                let command = params.command;
                line += command + " ";
                if (command === "M117") {
                    line += " " + params.message;
                    delete params.message;
                } else if (command === "M70") {
                    line += " P" + params.p + " " + params.message;
                    delete params.p;
                    delete params.message;
                }
            } else if (params.original) {
                line += params.original;
                delete params.original;
            }
            delete params.command;
            for (let param in params) {
                let val = params[param];
                if (val !== undefined) {
                    if (val === null) {
                        val = "";
                    }
                    line += param.toUpperCase() + val + " ";
                }
            }
            if (comment !== "") {
                line += comment;
            }
            output.push(line.trim());
        }
        return output.join("\n");
    }

    toString(): string {
        return "GCodeParser";
    }

}
